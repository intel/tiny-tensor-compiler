; Copyright (C) 2025 Intel Corporation
; SPDX-License-Identifier: BSD-3-Clause

include "tinytc/enums.anko"

inst @alloca "Alloca instruction" {
    prop %stack_ptr private => i64
    ret %result "memref type of allocated variable"
}

inst @arith "Arithmetic instruction (binary)" {
    prop %operation => @arithmetic "arithmetic operation type"
    op %a                          "left-hand operand"
    op %b                          "right-hand operand"
    ret %result                    "result type"
}

inst @arith_unary "Arithmetic instruction (unary)" {
    prop %operation => @arithmetic_unary "unary arithmetic operation type"
    op %a                                "operand"
    ret %result                          "result type"
}

inst @barrier "Barrier instruction" {
    prop %fence_flags => "tinytc_address_spaces_t" "address space(s) of memory fence; "
                                                   "set to 0 for no fence"
    cxx "auto has_fence(address_space as) -> bool;"
}

inst @builtin "Builtin instruction" {
    prop %builtin_type => @builtin "builtin type"
    ret %result                    "result type"
    cxx "auto kind() -> inst_execution_kind;"
}

inst @cast "Cast instruction" {
    op %a       "operand"
    ret %result "target type"
}

inst @compare "Comparison instruction" {
    prop %cond => @cmp_condition "comparison type"
    op %a                        "left-hand operand"
    op %b                        "right-hand operand"
    ret %result                  "result type"
}

inst @constant "Constant instruction" {
    skip_builder
    prop %value => "constant_value_type" "constant value"
    ret %result                          "type of constant"
    cxx "auto is_zero() -> bool;"
    cxx "auto is_identity() -> bool;"
}

inst @cooperative_matrix_apply "Cooperative matrix apply instruction" {
    op %a       "matrix"
    reg %body   "instructions to apply to coopmatrix entries"
    ret %result "result type"
    cxx "inline auto row() -> tinytc_value & { return body().param(0); }"
    cxx "inline auto col() -> tinytc_value & { return body().param(1); }"
    cxx "inline auto val() -> tinytc_value & { return body().param(2); }"
}

inst @cooperative_matrix_extract "Cooperative matrix extract instruction" {
    prop %index => i64 "index"
    op %mat            "matrix"
    ret %result        "result type"
}

inst @cooperative_matrix_insert "Cooperative matrix insert instruction" {
    prop %index => i64 "index"
    op %val            "value to insert"
    op %mat            "matrix"
    ret %result        "result type"
}

inst @cooperative_matrix_load "Cooperative matrix load instruction" {
    prop %t       => @transpose    "transposed load"
    prop %checked => @checked_flag "boundary check"
    op %operand                    "matrix"
    op %pos0                       "row offset"
    op %pos1                       "column offset"
    ret %result                    "result type"
}

inst @cooperative_matrix_mul_add "Cooperative matrix mul add instruction" {
    op %a       "a matrix"
    op %b       "b matrix"
    op %c       "c matrix"
    ret %result "result type"
    cxx "auto is_c_zero() -> bool;"
}

inst @cooperative_matrix_prefetch "Cooperative matrix prefetch instruction" {
    prop %cache_level => i32 "cache level; 0 is closest to the core"
    prop %rows        => i32 "number of rows"
    prop %cols        => i32 "number of columns"
    op %operand              "matrix"
    op %pos0                 "row offset"
    op %pos1                 "column offset"
}

inst @cooperative_matrix_reduce "Cooperative matrix reduce instruction" {
    prop %arith => @group_arithmetic "reduction operator"
    prop %mode  => @reduce_mode      "reduction mode"
    op %a                            "matrix"
    ret %result                      "result type"
}

inst @cooperative_matrix_scale "Cooperative matrix scale instruction" {
    op %a       "scalar"
    op %b       "matrix"
    ret %result "result type"
}

inst @cooperative_matrix_store "Cooperative matrix store instruction" {
    prop %checked => @checked_flag "boundary check"
    prop %flag    => @store_flag   "store mode"
    op %val                        "value to store"
    op %operand                    "matrix"
    op %pos0                       "row offset"
    op %pos1                       "column offset"
}


inst @expand "Expand instruction" {
    prop %expanded_mode        => i64 "expanded mode"
    prop* %static_expand_shape => i64 "static expand shape"
    op %operand                       "tensor"
    op* %expand_shape                 "dynamic expand shape"
    ret %result                       "result type"
}

inst @fuse "Fuse instruction" {
    prop %from => i64 "first mode to fuse"
    prop %to   => i64 "last mode to fuse"
    op %operand       "tensor"
    ret %result       "result type"
}

inst @if "If instruction"{
    op %condition  "condition"
    reg %then      "then block"
    reg %otherwise "else block"
    ret* %results  "return type array"
    cxx "auto is_otherwise_empty() -> bool;"
}

inst @lifetime_stop "Lifetime stop instruction" {
    op %object "stack object whose lifetime ends"
}


inst @load "Load instruction" {
    op %operand     "tensor or group of tensors"
    op* %index_list "indices"
    ret %result     "result type"
}

inst @math_unary "Math instruction" {
    prop %operation => @math_unary "function"
    op %a                          "argument"
    ret %result                    "result type"
}

inst @parallel "Parallel instruction" {
    reg %body "parallel region"
}

inst @size "Size instruction" {
    prop %mode => i64 "mode for which size is extracted"
    op %operand       "tensor"
    ret %result       "result type"
}

inst @subgroup_broadcast "Subgroup broadcast instruction" {
    op %a       "operand"
    op %idx     "subgroup local index"
    ret %result "result index"
}

inst @subgroup_operation "Subgroup operation instruction" {
    prop %arith     => @group_arithmetic "group arithmetic type"
    prop %operation => @group_operation  "group operation type"
    op %a                                "operand"
    ret %result                          "result type"
}

inst @subview "Subview instruction" {
    prop* %static_offsets => i64 "static offsets (need to add value to dynamic offsets "
                                 "if static_offsets[i] == TINYTC_DYNAMIC)"
    prop* %static_sizes   => i64 "static sizes (need to add value to dynamic sizes "
                                 "if static_sizes[i] == TINYTC_DYNAMIC)"
    op %operand                  "operand"
    op* %offsets                 "dynamic offsets"
    op* %sizes                   "dynamic sizes"
    ret %result                  "resulting memref type"
}

inst @store "Store instruction" {
    prop %flag => @store_flag "store flag"
    op %val                   "value to store"
    op %operand               "operand"
    op* %index_list           "indices"
}

inst @yield "Yield instruction" {
    op* %yielded_vals "yielded values"
}

inst @blas_a2 "BLAS instruction with 2 tensor arguments" {
    prop %atomic => bool "atomic flag"
    op %alpha            "alpha scalar"
    op %A                "A tensor"
    op %beta             "beta scalar"
    op %B                "B tensor"
}

inst @axpby : @blas_a2 "AXPBY instruction" {
    prop %tA => @transpose "transpose A"
}

inst @cumsum : @blas_a2 "Cumsum instruction" {
    prop %mode => i64 "sum mode"
}

inst @sum : @blas_a2 "Sum instruction" {
    prop %tA => @transpose "transpose A"
}

inst @blas_a3 "BLAS instruction with 3 tensor arguments" {
    prop %atomic => bool "atomic flag"
    op %alpha            "alpha scalar"
    op %A                "A tensor"
    op %B                "B tensor"
    op %beta             "beta scalar"
    op %C                "C tensor"
}

inst @gemm : @blas_a3 "GEMM instruction" {
    prop %tA => @transpose "transpose A"
    prop %tB => @transpose "transpose B"
}

inst @gemv : @blas_a3 "GEMV instruction" {
    prop %tA => @transpose "transpose A"
}

inst @ger : @blas_a3 "GER instruction" {}

inst @hadamard : @blas_a3 "Hadamard instruction" {}

inst @loop "Loop instruction" {
    reg %body "loop body"
}

inst @for : @loop "Create for loop" {
    op %from       "loop begin (inclusive)"
    op %to         "loop end (exclusive)"
    op? %step      "loop step"
    op* %iter_init "array of initial values"
    ret* %results  "array of return types"
    cxx "inline auto loop_var() -> tinytc_value & { return body().param(0); }"
    cxx "inline auto iter_arg(std::int64_t no) -> tinytc_value & { return body().param(no + 1); }"
}

inst @foreach : @loop "Create foreach loop" {
    op* %from "array of loop begin (inclusive)"
    op* %to   "array of loop end (exclusive)"
    cxx "inline auto dim() -> std::int32_t { return get().num_operands() / 2; }"
    cxx "inline auto loop_vars() { return body().params(); }"
}
