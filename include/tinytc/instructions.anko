; Copyright (C) 2025 Intel Corporation
; SPDX-License-Identifier: BSD-3-Clause

include "tinytc/enums.anko"

inst @alloca {
    prop %stack_ptr private => i64
    ret %result 'memref type of allocated variable'
}

inst @arith {
    prop %operation => @arithmetic
    op %a
    op %b
    ret %result
}

inst @arith_unary {
    prop %operation => @arithmetic_unary
    op %a
    ret %result
}

inst @barrier {
    prop %fence_flags => "tinytc_address_spaces_t"    
    cxx "auto has_fence(address_space as) -> bool;"
}

inst @builtin {
    prop %builtin_type => @builtin
    ret %result
    cxx "auto kind() -> inst_execution_kind;"
}

inst @cast {
    op %a
    ret %result
}

inst @compare {
    prop %cond => @cmp_condition
    op %a
    op %b
    ret %result
}

inst @constant {
    prop %value => "constant_value_type"
    ret %result
    cxx "auto is_zero() -> bool;"
    cxx "auto is_identity() -> bool;"
}

inst @cooperative_matrix_apply {
    op %a
    reg %body
    ret %result
    cxx "inline auto row() -> tinytc_value & { return body().param(0); }"
    cxx "inline auto col() -> tinytc_value & { return body().param(1); }"
    cxx "inline auto val() -> tinytc_value & { return body().param(2); }"
}

inst @cooperative_matrix_extract {
    prop %index => i64
    op %mat
    ret %result
}

inst @cooperative_matrix_insert {
    prop %index => i64
    op %val
    op %mat
    ret %result
}

inst @cooperative_matrix_load {
    prop %t       => @transpose
    prop %checked => @checked_flag
    op %operand
    op %pos0
    op %pos1
    ret %result
}

inst @cooperative_matrix_mul_add {
    op %a
    op %b
    op %c
    ret %result
    cxx "auto is_c_zero() -> bool;"
}

inst @cooperative_matrix_prefetch {
    prop %cache_level => i32
    prop %rows        => i32
    prop %cols        => i32
    op %operand
    op %pos0
    op %pos1
}

inst @cooperative_matrix_reduce {
    prop %arith => @group_arithmetic
    prop %mode  => @reduce_mode
    op %a
    ret %result
}

inst @cooperative_matrix_scale {
    op %a
    op %b
    ret %result
}

inst @cooperative_matrix_store {
    prop %checked => @checked_flag
    prop %flag    => @store_flag
    op %val
    op %operand
    op %pos0
    op %pos1
}


inst @expand {
    prop %expanded_mode        => i64
    prop* %static_expand_shape => i64
    op %operand
    op* %expand_shape
    ret %result
}

inst @fuse {
    prop %from => i64
    prop %to   => i64
    op %operand
    ret %result
}

inst @if {
    op %condition
    reg %then
    reg %otherwise
    ret* %results
    cxx "auto is_otherwise_empty() -> bool;"
}

inst @lifetime_stop {
    op %object
}


inst @load {
    op %operand
    op* %index_list
    ret %result
}

inst @math_unary {
    prop %operation => @math_unary
    op %a
    ret %result
}

inst @parallel {
    reg %body
}

inst @size {
    prop %mode => i64
    op %operand
    ret %result
}

inst @subgroup_broadcast {
    op %a
    op %idx
    ret %result
}

inst @subgroup_operation {
    prop %arith     => @group_arithmetic
    prop %operation => @group_operation
    op %a
    ret %result
}

inst @subview
'@brief Create subview instruction

@code %value = subview %operand[%offset1:%size1,...,%offsetN:%sizeN] : result @endcode
'
{
    prop* %static_offsets => i64 'static offsets (need to add value to dynamic offsets '
                                 'if static_offsets[i] == TINYTC_DYNAMIC)'
    prop* %static_sizes   => i64 'static sizes (need to add value to dynamic sizes '
                                 'if static_sizes[i] == TINYTC_DYNAMIC)'
    op %operand  'operand'
    op* %offsets 'dynamic offsets'
    op* %sizes   'dynamic sizes'
    ret %result  'resulting memref type'
}

inst @store {
    prop %flag => @store_flag
    op %val
    op %operand
    op* %index_list
}

inst @yield {
    op* %yielded_vals
}

inst @blas_a2 {
    prop %atomic => bool
    op %alpha
    op %A
    op %beta
    op %B
}

inst @axpby : @blas_a2 {
    prop %tA => @transpose
}

inst @cumsum : @blas_a2 {
    prop %mode => i64
}

inst @sum : @blas_a2 {
    prop %tA => @transpose
}

inst @blas_a3 {
    prop %atomic => bool
    op %alpha
    op %A
    op %B
    op %beta
    op %C
}

inst @gemm : @blas_a3 {
    prop %tA => @transpose
    prop %tB => @transpose
}

inst @gemv : @blas_a3 {
    prop %tA => @transpose
}

inst @ger : @blas_a3 {}

inst @hadamard : @blas_a3 {}

inst @loop {
    reg %body
}

inst @for : @loop
'@brief Create for loop

@code
for %loop_var = %from, %to, %step
    init(initial_value_list) -> (types(initial_value_list)) { }
@endcode'
{
    op %from       'loop begin (inclusive)'
    op %to         'loop end (exclusive)'
    op? %step      'loop step'
    op* %iter_init 'array of initial values'
    ret* %results  'array of return types'
    cxx "inline auto loop_var() -> tinytc_value & { return body().param(0); }"
    cxx "inline auto iter_arg(std::int64_t no) -> tinytc_value & { return body().param(no + 1); }"
}

inst @foreach : @loop {
    op* %from
    op* %to
    cxx "inline auto dim() -> std::int32_t { return get().num_operands() / 2; }"
    cxx "inline auto loop_vars() { return body().params(); }"
}
