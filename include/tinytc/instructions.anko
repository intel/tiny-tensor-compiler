; Copyright (C) 2025 Intel Corporation
; SPDX-License-Identifier: BSD-3-Clause

inst @alloca {
    prop %stack_ptr private => "std::int64_t"
    ret %result
}

inst @arith {
    prop %operation => "arithmetic"
    op %a
    op %b
    ret %result
}

inst @arith_unary {
    prop %operation => "arithmetic_unary"
    op %a
    ret %result
}

inst @barrier {
    prop %fence_flags => "tinytc_address_spaces_t"    
    cxx "auto has_fence(address_space as) -> bool;"
}

inst @builtin {
    prop %builtin_type => "builtin"
    ret %result
    cxx "auto kind() -> inst_execution_kind;"
}

inst @cast {
    op %a
    ret %result
}

inst @compare {
    prop %cond => "cmp_condition"
    op %a
    op %b
    ret %result
}

inst @constant {
    prop %value => "constant_value_type"
    ret %result
    cxx "auto is_zero() -> bool;"
    cxx "auto is_identity() -> bool;"
}

inst @cooperative_matrix_apply {
    op %a
    reg %body
    ret %result
    cxx "inline auto row() -> tinytc_value & { return body().param(0); }"
    cxx "inline auto col() -> tinytc_value & { return body().param(1); }"
    cxx "inline auto val() -> tinytc_value & { return body().param(2); }"
}

inst @cooperative_matrix_extract {
    prop %index => "std::int64_t"
    op %mat
    ret %result
}

inst @cooperative_matrix_insert {
    prop %index => "std::int64_t"
    op %val
    op %mat
    ret %result
}

inst @cooperative_matrix_load {
    prop %t => "transpose"
    prop %checked => "checked_flag"
    op %operand
    op %pos0
    op %pos1
    ret %result
}

inst @cooperative_matrix_mul_add {
    op %a
    op %b
    op %c
    ret %result
    cxx "auto is_c_zero() -> bool;"
}

inst @cooperative_matrix_prefetch {
    prop %cache_level => "std::int32_t"
    prop %rows => "std::int32_t"
    prop %cols => "std::int32_t"
    op %operand
    op %pos0
    op %pos1
}

inst @cooperative_matrix_reduce {
    prop %arith => "group_arithmetic"
    prop %mode => "reduce_mode"
    op %a
    ret %result
}

inst @cooperative_matrix_scale {
    op %a
    op %b
    ret %result
}

inst @cooperative_matrix_store {
    prop %checked => "checked_flag"
    prop %flag => "store_flag"
    op %val
    op %operand
    op %pos0
    op %pos1
}


inst @expand {
    prop %expanded_mode => "std::int64_t"
    prop* %static_expand_shape => "std::int64_t"
    op %operand
    op* %expand_shape
    ret %result
}

inst @fuse {
    prop %from => "std::int64_t"
    prop %to => "std::int64_t"
    op %operand
    ret %result
}

inst @if {
    op %condition
    reg %then
    reg %otherwise
    ret* %results
    cxx "auto is_otherwise_empty() -> bool;"
}

inst @lifetime_stop {
    op %object
}


inst @load {
    op %operand
    op* %index_list
    ret %result
}

inst @math_unary {
    prop %operation => "math_unary"
    op %a
    ret %result
}

inst @parallel {
    reg %body
}

inst @size {
    prop %mode => "std::int64_t"
    op %operand
    ret %result
}

inst @subgroup_broadcast {
    op %a
    op %idx
    ret %result
}

inst @subgroup_operation {
    prop %arith => "group_arithmetic"
    prop %operation => "group_operation"
    op %a
    ret %result
}

inst @subview {
    prop* %static_offsets => "std::int64_t"
    prop* %static_sizes => "std::int64_t"
    op %operand
    op* %offsets
    op* %sizes
    ret %result
}

inst @store {
    prop %flag => "store_flag"
    op %val
    op %operand
    op* %index_list
}

inst @yield {
    op* %yielded_vals
}

inst @blas_a2 {
    prop %atomic => "bool"
    op %alpha
    op %A
    op %beta
    op %B
}

inst @axpby : @blas_a2 {
    prop %tA => "transpose"
}

inst @cumsum : @blas_a2 {
    prop %mode => "std::int64_t"
}

inst @sum : @blas_a2 {
    prop %tA => "transpose"
}

inst @blas_a3 {
    prop %atomic => "bool"
    op %alpha
    op %A
    op %B
    op %beta
    op %C
}

inst @gemm : @blas_a3 {
    prop %tA => "transpose"
    prop %tB => "transpose"
}

inst @gemv : @blas_a3 {
    prop %tA => "transpose"
}

inst @ger : @blas_a3 {}

inst @hadamard : @blas_a3 {}

inst @loop {
    reg %body
}

inst @for : @loop {
    op %from
    op %to
    op? %step
    op* %iter_init
    ret* %results
    cxx "inline auto loop_var() -> tinytc_value & { return body().param(0); }"
    cxx "inline auto iter_arg(std::int64_t no) -> tinytc_value & { return body().param(no + 1); }"
}

inst @foreach : @loop {
    op* %from
    op* %to
    cxx "inline auto dim() -> std::int32_t { return get().num_operands() / 2; }"
    cxx "inline auto loop_vars() { return body().params(); }"
}
