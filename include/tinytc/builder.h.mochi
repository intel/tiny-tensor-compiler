// Copyright (C) 2025 Intel Corporation
// SPDX-License-Identifier: BSD-3-Clause

#ifndef BUILDER_H_20250625
#define BUILDER_H_20250625

#include "tinytc/export.h"
#include "tinytc/types.h"

#include <stddef.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

////////////////////////////
///////// Attribute ////////
////////////////////////////

/**
 * @brief Get array attribute
 *
 * @param attr [out] pointer to the attribute object
 * @param ctx [inout] compiler context
 * @param array_size [in] number of elements in array, must be 0 if array == nullptr
 * @param array [in][range(0, array_size)] attribute array
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_array_attr_get(tinytc_attr_t *attr,
                                                    tinytc_compiler_context_t ctx,
                                                    size_t array_size, const tinytc_attr_t *array);

/**
 * @brief Get boolean attribute
 *
 * @param attr [out] pointer to the attribute object
 * @param ctx [inout] compiler context
 * @param value [in] value of attribute
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_boolean_attr_get(tinytc_attr_t *attr,
                                                      tinytc_compiler_context_t ctx,
                                                      tinytc_bool_t value);

/**
 * @brief Get dictionary attribute
 *
 * Each name must only appear once.
 *
 * @param attr [out] pointer to the attribute object
 * @param ctx [inout] compiler context
 * @param items_size [in] number of elements in items array, must be 0 if items == nullptr
 * @param items [in][range(0, items_size)] array of items
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_dictionary_attr_get(tinytc_attr_t *attr,
                                                         tinytc_compiler_context_t ctx,
                                                         size_t items_size,
                                                         tinytc_named_attr_t *items);

/**
 * @brief Get dictionary attribute with pre-sorted items
 *
 * The list of items must be sorted by name and each name must only appear once.
 *
 * @param attr [out] pointer to the attribute object
 * @param ctx [inout] compiler context
 * @param items_size [in] number of elements in items array, must be 0 if items == nullptr
 * @param items [in][range(0, items_size)] array of items
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t
tinytc_dictionary_attr_get_with_sorted(tinytc_attr_t *attr, tinytc_compiler_context_t ctx,
                                       size_t items_size, const tinytc_named_attr_t *items);

/**
 * @brief Sort items array by name
 *
 * @param items_size [in] number of elements in items array, must be 0 if items == nullptr
 * @param items [in][range(0, items_size)] array of items
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_dictionary_attr_sort(size_t items_size,
                                                          tinytc_named_attr_t *items);

/**
 * @brief Get integer attribute
 *
 * @param attr [out] pointer to the attribute object
 * @param ctx [inout] compiler context
 * @param value [in] value of attribute
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_integer_attr_get(tinytc_attr_t *attr,
                                                      tinytc_compiler_context_t ctx, int64_t value);

/**
 * @brief Get string attribute
 *
 * @param attr [out] pointer to the attribute object
 * @param ctx [inout] compiler context
 * @param str_length [in] number of characters (not including a null terminator)
 * @param str [in] string; not necessarily null-terminated
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_string_attr_get(tinytc_attr_t *attr,
                                                     tinytc_compiler_context_t ctx,
                                                     size_t str_length, char const *str);

////////////////////////////
//////// Scalar type ///////
////////////////////////////

//! Size of scalar type in bytes
TINYTC_EXPORT size_t tinytc_scalar_type_size(tinytc_scalar_type_t ty);

////////////////////////////
///////// Data type ////////
////////////////////////////

/**
 * @brief Get boolean data type
 *
 * @param dt [out] pointer to the data type object created
 * @param ctx [inout] compiler context
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_boolean_type_get(tinytc_type_t *dt,
                                                      tinytc_compiler_context_t ctx);

/**
 * @brief Get scalar data type
 *
 * @param dt [out] pointer to the data type object created
 * @param ctx [inout] compiler context
 * @param type [in] scalar type
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_scalar_type_get(tinytc_type_t *dt,
                                                     tinytc_compiler_context_t ctx,
                                                     tinytc_scalar_type_t type);

/**
 * @brief Get memref data type
 *
 * Note: modifies compiler context
 *
 * @param dt [out] pointer to the data type object created
 * @param scalar_ty [in] element type
 * @param shape_size [in] tensor order; number of elements in shape array, must be 0 if shape ==
 * nullptr
 * @param shape [in][range(0, shape_size)] array of mode sizes
 * @param stride_size [in][optional] number of elements in stride array; must be either 0 for
 * automatic stride calculation or must match shape_size; must be 0 if stride == nullptr
 * @param stride [in][optional][range(0, stride_size)] stride array
 * @param addrspace [in][optional] Address space; default is tinytc_address_space_global
 * @param loc [in][optional] Source code location; can be nullptr
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_memref_type_get(tinytc_type_t *dt, tinytc_type_t scalar_ty,
                                                     size_t shape_size, const int64_t *shape,
                                                     size_t stride_size, const int64_t *stride,
                                                     tinytc_address_space_t addrspace,
                                                     const tinytc_location_t *loc);

/**
 * @brief Get group data type
 *
 * Note: modifies compiler context
 *
 * @param dt [out] pointer to the data type object created
 * @param memref_ty [in] memref data type object
 * @param size [in] group size; may be TINYTC_DYNAMIC
 * @param offset [in][optional] offset parameter; pass 0 for default; may be TINYTC_DYNAMIC
 * @param loc [in][optional] Source code location; can be nullptr
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_group_type_get(tinytc_type_t *dt, tinytc_type_t memref_ty,
                                                    int64_t size, int64_t offset,
                                                    const tinytc_location_t *loc);
/**
 * @brief Get coopmatrix data type
 *
 * Note: modifies compiler context
 *
 * @param dt [out] pointer to the data type object created
 * @param scalar_ty [in] component type
 * @param rows [in] number of rows
 * @param cols [in] number of cols
 * @param use [in] matrix use
 * @param loc [in][optional] Source code location; can be nullptr
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_coopmatrix_type_get(tinytc_type_t *dt, tinytc_type_t scalar_ty,
                                                         int64_t rows, int64_t cols,
                                                         tinytc_matrix_use_t use,
                                                         const tinytc_location_t *loc);
/**
 * @brief Get void data type
 *
 * @param dt [out] pointer to the data type object created
 * @param ctx [inout] compiler context
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_void_type_get(tinytc_type_t *dt,
                                                   tinytc_compiler_context_t ctx);

////////////////////////////
/////////// Value //////////
////////////////////////////

/**
 * @brief Set name of value
 *
 * @param vl [inout] value object
 * @param name [in] name; null-terminated string
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_value_set_name(tinytc_value_t vl, char const *name);

/**
 * @brief Set name of value with explicit number of characters
 *
 * @param vl [inout] value object
 * @param name_length [in] number of characters
 * @param name [in] name; not necessarily null-terminated
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_value_set_name_n(tinytc_value_t vl, size_t name_length,
                                                      char const *name);

/**
 * @brief Get name of value
 *
 * The returned pointer may be invalidated if the value or any node in the abstract syntax
 * tree referencing the value is modified.
 *
 * @param vl [in] value object
 * @param name [out] pointer to C string
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_value_get_name(const_tinytc_value_t vl, char const **name);

/**
 * @brief Get type of value
 *
 * @param vl [in] value object
 * @param ty [out] pointer to data type
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_value_get_type(const_tinytc_value_t vl, tinytc_type_t *ty);

////////////////////////////
/////// Instructions ///////
////////////////////////////

// もち api_builder_h "tinytc/instructions.anko"

/**
 * @brief Create boolean constant instruction
 *
 * @param instr [out] pointer to the inst object created
 * @param value [in] constant value
 * @param ty [in] type of constant
 * @param loc [in][optional] Source code location; can be nullptr
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_constant_inst_create_boolean(tinytc_inst_t *instr,
                                                                  tinytc_bool_t value,
                                                                  tinytc_type_t ty,
                                                                  const tinytc_location_t *loc);

/**
 * @brief Create complex constant instruction
 *
 * @param instr [out] pointer to the inst object created
 * @param value_re [in] constant value (real part)
 * @param value_im [in] constant value (imaginary part)
 * @param ty [in] type of constant
 * @param loc [in][optional] Source code location; can be nullptr
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_constant_inst_create_complex(tinytc_inst_t *instr,
                                                                  double value_re, double value_im,
                                                                  tinytc_type_t ty,
                                                                  const tinytc_location_t *loc);

/**
 * @brief Create floating constant instruction
 *
 * @param instr [out] pointer to the inst object created
 * @param value [in] constant value
 * @param ty [in] type of constant
 * @param loc [in][optional] Source code location; can be nullptr
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_constant_inst_create_float(tinytc_inst_t *instr, double value,
                                                                tinytc_type_t ty,
                                                                const tinytc_location_t *loc);

/**
 * @brief Create integer constant instruction
 *
 * @param instr [out] pointer to the inst object created
 * @param value [in] constant value
 * @param ty [in] type of constant
 * @param loc [in][optional] Source code location; can be nullptr
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_constant_inst_create_int(tinytc_inst_t *instr, int64_t value,
                                                              tinytc_type_t ty,
                                                              const tinytc_location_t *loc);

/**
 * @brief Creates the multiplicative identity constant (i.e. "1") for the given data type
 *
 * @param instr [out] pointer to the inst object created
 * @param ty [in] type of constant
 * @param loc [in][optional] Source code location; can be nullptr
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_constant_inst_create_one(tinytc_inst_t *instr,
                                                              tinytc_type_t ty,
                                                              const tinytc_location_t *loc);

/**
 * @brief Creates the additive identity constant (i.e. "0") for the given data type
 *
 * @param instr [out] pointer to the inst object created
 * @param ty [in] type of constant
 * @param loc [in][optional] Source code location; can be nullptr
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_constant_inst_create_zero(tinytc_inst_t *instr,
                                                               tinytc_type_t ty,
                                                               const tinytc_location_t *loc);

////////////////////////////
/////// Instructions ///////
////////////////////////////

/**
 * @brief Get parent region of instruction
 *
 * @param instr [in] inst object
 * @param parent [out] parent region
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_inst_get_parent_region(tinytc_inst_t instr,
                                                            tinytc_region_t *parent);

/**
 * @brief Get child regions of instruction
 *
 * Function can be called with result_list_size = 0 and result_list = nullptr in order to obtain
 * the number of results
 *
 * @param instr [in] inst object
 * @param result_list_size [inout] pointer to the number of results; if result_list_size is 0, then
 * it is updated with the number of results; if result_list_size is greater than the number of
 * results, the value is updated with the correct number of results
 * @param result_list [out][range(0, result_list_size)] user-provided memory for storing result
 * handles; at most result_list_size values are written; can be nullptr if result_list_size is 0
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_inst_get_regions(tinytc_inst_t instr, size_t *result_list_size,
                                                      tinytc_region_t *result_list);

/**
 * @brief Get values produced by instruction
 *
 * Function can be called with result_list_size = 0 and result_list = nullptr in order to obtain
 * the number of results
 *
 * @param instr [in] inst object
 * @param result_list_size [inout] pointer to the number of results; if result_list_size is 0, then
 * it is updated with the number of results; if result_list_size is greater than the number of
 * results, the value is updated with the correct number of results
 * @param result_list [out][range(0, result_list_size)] user-provided memory for storing result
 * handles; at most result_list_size values are written; can be nullptr if result_list_size is 0
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_inst_get_values(tinytc_inst_t instr, size_t *result_list_size,
                                                     tinytc_value_t *result_list);

/**
 * @brief Set instruction attributes
 *
 * @param instr [inout] inst object
 * @param a [in] attribute object (dictionary attribute)
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_inst_set_attr(tinytc_inst_t instr, tinytc_attr_t a);

////////////////////////////
////////// Region //////////
////////////////////////////

/**
 * @brief Append instruction to region
 *
 * The region takes ownership of the instruction.
 * An instruction must not be added to multiple regions.
 *
 * @param reg [inout] region object
 * @param instr [in,pass_ownership] instruction
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_region_append(tinytc_region_t reg, tinytc_inst_t instr);

/**
 * @brief Returns iterator pointing to begin of the region
 *
 * @param reg [in] region
 * @param iterator [out] inst iterator
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_region_begin(tinytc_region_t reg,
                                                  tinytc_inst_iterator_t *iterator);

/**
 * @brief Returns iterator pointing to the end of the region
 *
 * The end iterator must not be dereferenced.
 *
 * @param reg [in] region]
 * @param iterator [out] inst iterator
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_region_end(tinytc_region_t reg,
                                                tinytc_inst_iterator_t *iterator);

/**
 * @brief Erase instruction at the position of the iterator
 *
 * The iterator is updated to point to the instruction coming after the iterator or the end iterator
 *
 * @param reg [inout] region object
 * @param iterator [inout] iterator
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_region_erase(tinytc_region_t reg,
                                                  tinytc_inst_iterator_t *iterator);

/**
 * @brief Insert instruction at the position before the iterator
 *
 * The iterator is updated to point to the instruction that was just inserted.
 *
 * The region takes ownership of the instruction.
 * An instruction must not be inserted into multiple regions.
 *
 * @param reg [inout] region object
 * @param iterator [inout]
 * @param instr [in,pass_ownership]
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_region_insert(tinytc_region_t reg,
                                                   tinytc_inst_iterator_t *iterator,
                                                   tinytc_inst_t instr);

/**
 * @brief Move iterator to the next instruction
 *
 * @param iterator [inout] iterator
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_next_inst(tinytc_inst_iterator_t *iterator);

/**
 * @brief Move iterator to the previous instruction
 *
 * @param iterator [inout] iterator
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_prev_inst(tinytc_inst_iterator_t *iterator);

/**
 * @brief Get region parameters
 *
 * Function can be called with result_list_size = 0 and result_list = nullptr in order to obtain
 * the number of results
 *
 * @param reg [in] region object
 * @param result_list_size [inout] pointer to the number of results; if result_list_size is 0, then
 * it is updated with the number of results; if result_list_size is greather than the number of
 * results, the value is updated with the correct number of results
 * @param result_list [out][range(0, result_list_size)] user-provided memory for storing result
 * handles; at most result_list_size values are written; can be nullptr if result_list_size is 0
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_region_get_parameters(tinytc_region_t reg,
                                                           size_t *result_list_size,
                                                           tinytc_value_t *result_list);

////////////////////////////
/////////// Func ///////////
////////////////////////////

/**
 * @brief Create function
 *
 * Function takes ownership of region.
 *
 * @param fun [out] pointer to the func object created
 * @param name_length [in] length of function_name
 * @param name [in] function name
 * @param num_params [in] number of parameters
 * @param param_type_list [in][range(0,num_params)] parameter data types; can be nullptr if
 * num_params is 0
 * @param ty [in] result type (must be void for host-callable function)
 * @param loc [in][optional] Source code location; can be nullptr
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_func_create(tinytc_func_t *fun, size_t name_length,
                                                 char const *name, size_t num_params,
                                                 const tinytc_type_t *param_type_list,
                                                 tinytc_type_t ty, const tinytc_location_t *loc);

/**
 * @brief Set function attributes
 *
 * @param fun [inout] function object
 * @param a [in] attribute dictionary
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_func_set_attr(tinytc_func_t fun, tinytc_attr_t a);

/**
 * @brief Set parameter attributes
 *
 * @param fun [in] function object
 * @param param_no [in] paramater number (0 to num_parameters-1)
 * @param a [in] attribute dictionary
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_func_set_parameter_attr(tinytc_func_t fun, size_t param_no,
                                                             tinytc_attr_t a);

/**
 * @brief Get function body
 *
 * @param fun [in] function object
 * @param body [out] pointer to body region
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_func_get_body(tinytc_func_t fun, tinytc_region_t *body);

////////////////////////////
/////////// Prog ///////////
////////////////////////////

/**
 * @brief Create program
 *
 * @param prg [out] pointer to the prog object created
 * @param ctx [in] compiler context object
 * @param loc [in][optional] Source code location; can be nullptr
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_prog_create(tinytc_prog_t *prg, tinytc_compiler_context_t ctx,
                                                 const tinytc_location_t *loc);

/**
 * @brief Append function to program
 *
 * The program takes ownership of the function.
 * A function must not be added to multiple programs nor must the user destroy the function after
 * adding it to the program.
 *
 * @param prg [inout] program object
 * @param fun [in,pass_ownership] function object
 *
 * @return tinytc_status_success on success and error otherwise
 */
TINYTC_EXPORT tinytc_status_t tinytc_prog_add_function(tinytc_prog_t prg, tinytc_func_t fun);

#ifdef __cplusplus
}
#endif

#endif // BUILDER_H_20250625
