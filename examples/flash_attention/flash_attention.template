; Copyright (C) 2025 Intel Corporation
; SPDX-License-Identifier: BSD-3-Clause

$QKVO_gcd = {stride_gcd=[1,$headdim,$headdim,$headdim]}
$num_sg_x = !calc($headdim 32 /)
$num_sg_y = !calc($block_size 32 /)
$sgs = 16
$wg_size_x = !calc($num_sg_x $sgs *)
$wg_size_y = $num_sg_y
$func_attr = {subgroup_size=$sgs, work_group_size=[$wg_size_x,$wg_size_y]}

; %Q: (d,N,H)
; %K: (d,N,H)
; %V: (d,N,H)
; %O: (d,N,H)
func @flash_attention(%Q: memref<$dtype x $headdim x?x?x?> $QKVO_gcd,
                      %K: memref<$dtype x $headdim x?x?x?> $QKVO_gcd,
                      %V: memref<$dtype x $headdim x?x?x?> $QKVO_gcd,
                      %O: memref<$dtype x $headdim x?x?x?> $QKVO_gcd,
                      %scale_factor: f32)
                      attributes $func_attr {
    %c0 = constant 0 : index
    %c16 = constant 16 : index
    %c32 = constant 32 : index
    %c64 = constant 64 : index
    %c128 = constant 128 : index
    %c256 = constant 256 : index
    %cnum_subgroups_x = constant $num_sg_x : index
    %cheaddim = constant $headdim : index
    %cblock_size = constant $block_size : index

    %row_block = group_id.x : index
    %head = group_id.y : index
    %batch = group_id.z : index

    %clog2e = constant 1.44269504088896340736 : f32
    %scale = mul %scale_factor, %clog2e : f32

    %seq_offset = mul %row_block, %cblock_size : index
    %seq_len = size %Q[1] : index
    %seq_remainder = sub %seq_len, %seq_offset : index
    %seq_block_size = min %cblock_size, %seq_remainder : index

    %q = subview %Q[0:$headdim,%seq_offset:%seq_block_size,%head,%batch] : memref<$dtype x$headdim x?,strided<1,?>>
    %k = subview %K[0:$headdim,%c0:%seq_len,%head,%batch] : memref<$dtype x$headdim x?,strided<1,?>>
    %v = subview %V[0:$headdim,%c0:%seq_len,%head,%batch] : memref<$dtype x$headdim x?,strided<1,?>>
    %o = subview %O[0:$headdim,%seq_offset:%seq_block_size,%head,%batch] : memref<$dtype x$headdim x?,strided<1,?>>

    %P = alloca {alignment=64} : memref<$dtype x32x32x $num_sg_x x $num_sg_y,local>
    %maxvec = alloca {alignment=64} : memref<f32x $block_size x 1,local>
    %maxvec_diff_exp_tmp = alloca {alignment=64} : memref<f32x $block_size x 1,local>
    %normvec = alloca {alignment=64} : memref<f32x $block_size x 1,local>

    parallel {
        %o_init = constant 0.0 : coopmatrix<f32x32x32,matrix_acc>
        %s_init = constant 0.0 : coopmatrix<f32x32x32,matrix_acc>
        %maxvec_init = constant -inf : coopmatrix<f32x32x1,matrix_acc>
        %normvec_init = constant 0.0 : coopmatrix<f32x32x1,matrix_acc>
        %m_ones = constant -1.0 : coopmatrix<f32x1x32,matrix_b>
        %ones = constant 1.0 : coopmatrix<f32x32x1,matrix_a>

        %l_y = subgroup_id.y : i32
        %l_y_idx = cast %l_y : index
        %j0 = mul %c32, %l_y_idx : index

        %l_x = subgroup_id.x : i32
        %l_x_idx = cast %l_x : index
        %i0 = mul %c32, %l_x_idx : index
        %n0 = mul %c32, %l_x_idx : index

        %c0_i32 = constant 0 : i32
        %is_first_x = equal %l_x, %c0_i32 : bool
        if %is_first_x {
            cooperative_matrix_store %maxvec_init, %maxvec[%j0,%c0]
            cooperative_matrix_store %normvec_init, %normvec[%j0,%c0]
        }
        barrier.local

        %n_step = mul %c32, %cnum_subgroups_x : index

        %o_acc,%maxvec_acc = for %n=%c0,%seq_len,%n_step
            init(%o_iter=%o_init,%maxvec_iter=%maxvec_init)
            -> (coopmatrix<f32x32x32,matrix_acc>,coopmatrix<f32x32x1,matrix_acc>) {
            %n_kq = add %n, %n0 : index
            cooperative_matrix_prefetch 0, %v[%i0,%n_kq], 32, 32

            %shat = for %m=%c0,%cheaddim,%c32 init(%s_iter=%s_init) -> (coopmatrix<f32x32x32,matrix_acc>) {
                %kk = cooperative_matrix_load.cols_checked %k[%m,%n_kq] : coopmatrix<$dtype x32x32,matrix_b>
                %qq = cooperative_matrix_load.t.rows_checked %q[%m,%j0] : coopmatrix<$dtype x32x32,matrix_a>
                %m_next = add %m, %c32 : index
                %s_next = cooperative_matrix_mul_add %qq, %kk, %s_iter : coopmatrix<f32x32x32,matrix_acc>
                yield (%s_next)
            } attributes{unroll=false}
            %s = cooperative_matrix_scale %scale, %shat : coopmatrix<f32x32x32,matrix_acc>

            ;%n_next = add %n_kq, %cheaddim : index
            ;cooperative_matrix_prefetch 0, %k[%c0,%n_next], 128, 32

            %s_red = cooperative_matrix_reduce_max.row %s : coopmatrix<f32x32x1,matrix_acc>
            %s_red_up = cooperative_matrix_atomic_max %s_red, %maxvec[%j0,%c0] : coopmatrix<f32x32x1,matrix_acc> 
            barrier.local
            %maxvec_next = cooperative_matrix_load.n %maxvec[%j0,%c0] : coopmatrix<f32x32x1,matrix_acc>

            %maxvec_next_a = cast %maxvec_next : coopmatrix<f32x32x1,matrix_a>
            %s_diff = cooperative_matrix_mul_add %maxvec_next_a, %m_ones, %s : coopmatrix<f32x32x32,matrix_acc>
            %p = cooperative_matrix_apply (%x,%y,%val)=%s_diff -> coopmatrix<f32x32x32,matrix_acc> {
                %expval = native_exp2 %val : f32
                yield (%expval)
            }
            %p_f16 = cast %p : coopmatrix<$dtype x32x32,matrix_acc>
            %P_sub = subview %P[0:32,0:32,%l_x_idx,%l_y_idx] : memref<$dtype x32x32,local>
            cooperative_matrix_store.t %p_f16, %P_sub[%c0,%c0]

            %maxvec_diff = sub %maxvec_iter, %maxvec_next : coopmatrix<f32x32x1,matrix_acc>
            %maxvec_diff_exp = cooperative_matrix_apply (%x,%y,%val)=%maxvec_diff
                                    -> coopmatrix<f32x32x1,matrix_acc> {
                %expval = native_exp2 %val : f32
                yield (%expval)
            }
            cooperative_matrix_store %maxvec_diff_exp, %maxvec_diff_exp_tmp[%j0,%c0]

            if %is_first_x {
                %normvec_last = cooperative_matrix_load.n %normvec[%j0,%c0] : coopmatrix<f32x32x1,matrix_acc>
                %normvec_rescaled = mul %maxvec_diff_exp, %normvec_last : coopmatrix<f32x32x1,matrix_acc>
                cooperative_matrix_store %normvec_rescaled, %normvec[%j0,%c0]
            }
            %p_red = cooperative_matrix_reduce_add.row %p : coopmatrix<f32x32x1,matrix_acc>
            barrier.local
            %p_red_up = cooperative_matrix_atomic_add %p_red, %normvec[%j0,%c0] : coopmatrix<f32x32x1,matrix_acc>

            %o_update = for %m=%c0,%n_step,%c32
                                    init(%o_inner_iter=%o_init)
                                    -> (coopmatrix<f32x32x32,matrix_acc>) {
                %n_vp = add %n, %m : index
                %m_block = div %m, %c32 : index
                %P_sub_m = subview %P[0:32,0:32,%m_block,%l_y_idx] : memref<$dtype x32x32,local>

                %vv = cooperative_matrix_load.cols_checked %v[%i0,%n_vp] : coopmatrix<$dtype x32x32,matrix_a>
                %pp1 = cooperative_matrix_load %P_sub_m[%c0,%c0] : coopmatrix<$dtype x32x32,matrix_b>
                %o_inner_next = cooperative_matrix_mul_add %vv, %pp1, %o_inner_iter : coopmatrix<f32x32x32,matrix_acc>
                yield (%o_inner_next)
            } attributes{unroll=false}

            %maxvec_diff_exp_b = cooperative_matrix_load.t %maxvec_diff_exp_tmp[%j0,%c0] : coopmatrix<f32x1x32,matrix_b>
            %maxvec_mat = cooperative_matrix_mul_add %ones, %maxvec_diff_exp_b, %o_init : coopmatrix<f32x32x32,matrix_acc>
            %o_iter_rescaled = mul %maxvec_mat, %o_iter : coopmatrix<f32x32x32,matrix_acc>
            %o_next = add %o_iter_rescaled, %o_update : coopmatrix<f32x32x32,matrix_acc>

            yield (%o_next,%maxvec_next)
        } attributes{unroll=false}
        barrier.local
        %normvec_final = cooperative_matrix_load.t %normvec[%j0,%c0] : coopmatrix<f32x1x32,matrix_b>
        %ones32 = constant 1.0 : coopmatrix<f32x1x32,matrix_b>
        %normvec_inv = div %ones32, %normvec_final : coopmatrix<f32x1x32,matrix_b>
        %normvec_inv_mat = cooperative_matrix_mul_add %ones, %normvec_inv, %o_init : coopmatrix<f32x32x32,matrix_acc>
        %o_scaled = mul %normvec_inv_mat, %o_acc : coopmatrix<f32x32x32,matrix_acc>
        %o_scaled_f16 = cast %o_scaled : coopmatrix<$dtype x32x32,matrix_acc>
        cooperative_matrix_store.cols_checked %o_scaled_f16, %o[%i0,%j0]
    }
}

; %Q: (d,N,H)
; %K: (d,N,H)
; %V: (d,N,H)
; %O: (d,N,H)
func @flash_attention_64(%Q: memref<$dtype x64x?x?x?> {stride_gcd=[1,64,64,64]},
                         %K: memref<$dtype x64x?x?x?> {stride_gcd=[1,64,64,64]},
                         %V: memref<$dtype x64x?x?x?> {stride_gcd=[1,64,64,64]},
                         %O: memref<$dtype x64x?x?x?> {stride_gcd=[1,64,64,64]},
                         %scale_factor: f32)
                         attributes{subgroup_size=16, work_group_size=[16,32]} {
    %block_size = constant 512 : index
    %row_block = group_id.x : index
    %head = group_id.y : index
    %batch = group_id.z : index

    %c0 = constant 0 : index
    %c16 = constant 16 : index
    %c32 = constant 32 : index
    %c64 = constant 64 : index
    %c512 = constant 512 : index
    %clog2e = constant 1.44269504088896340736 : f32
    %scale = mul %scale_factor, %clog2e : f32

    %seq_offset = mul %row_block, %block_size : index
    %seq_len = size %Q[1] : index
    %seq_remainder = sub %seq_len, %seq_offset : index
    %seq_block_size = min %block_size, %seq_remainder : index

    %q = subview %Q[0:64,%seq_offset:%seq_block_size,%head,%batch] : memref<$dtype x64x?,strided<1,?>>
    %k = subview %K[0:64,%c0:%seq_len,%head,%batch] : memref<$dtype x64x?,strided<1,?>>
    %v = subview %V[0:64,%c0:%seq_len,%head,%batch] : memref<$dtype x64x?,strided<1,?>>
    %o = subview %O[0:64,%seq_offset:%seq_block_size,%head,%batch] : memref<$dtype x64x?,strided<1,?>>

    parallel {
        %o_init = constant 0.0 : coopmatrix<f32x32x16,matrix_acc>
        %s_init = constant 0.0 : coopmatrix<f32x32x16,matrix_acc>
        %maxvec_init = constant -inf : coopmatrix<f32x1x16,matrix_acc>
        %normvec_init = constant 0.0 : coopmatrix<f32x1x16,matrix_acc>
        %m_ones = constant -1.0 : coopmatrix<f32x32x1,matrix_a>
        %ones = constant 1.0 : coopmatrix<f32x32x1,matrix_a>

        %l_y = subgroup_id.y : i32
        %l_y_idx = cast %l_y : index
        %j0 = mul %c16, %l_y_idx : index

        for %j=%j0,%block_size,%c512 {
            %o_acc1,%o_acc2,%maxvec,%normvec = for %n=%c0,%seq_len,%c32
                init(%o_iter1=%o_init,%o_iter2=%o_init,
                     %maxvec_iter=%maxvec_init,%normvec_iter=%normvec_init)
                -> (coopmatrix<f32x32x16,matrix_acc>,coopmatrix<f32x32x16,matrix_acc>,
                    coopmatrix<f32x1x16,matrix_acc>,coopmatrix<f32x1x16,matrix_acc>) {
                cooperative_matrix_prefetch 0, %v[%c0,%n], 32, 32
                cooperative_matrix_prefetch 0, %v[%c32,%n], 32, 32

                %shat = for %m=%c0,%c64,%c32 init(%s_iter=%s_init) -> (coopmatrix<f32x32x16,matrix_acc>) {
                    %kk = cooperative_matrix_load.t.rows_checked %k[%m,%n] : coopmatrix<$dtype x32x32,matrix_a>
                    %qq = cooperative_matrix_load.cols_checked %q[%m,%j] : coopmatrix<$dtype x32x16,matrix_b>
                    %s_next = cooperative_matrix_mul_add %kk, %qq, %s_iter : coopmatrix<f32x32x16,matrix_acc>
                    yield (%s_next)
                } attributes{unroll=true}
                %s = cooperative_matrix_scale %scale, %shat : coopmatrix<f32x32x16,matrix_acc>

                %n_next = add %n, %c32 : index
                cooperative_matrix_prefetch 0, %k[%c0,%n_next], 64, 32

                %s_red = cooperative_matrix_reduce_max.column %s : coopmatrix<f32x1x16,matrix_acc>
                %maxvec_next = max %maxvec_iter, %s_red : coopmatrix<f32x1x16,matrix_acc>

                %maxvec_next_b = cast %maxvec_next : coopmatrix<f32x1x16,matrix_b>
                %s_diff = cooperative_matrix_mul_add %m_ones, %maxvec_next_b, %s : coopmatrix<f32x32x16,matrix_acc>
                %p = cooperative_matrix_apply (%x,%y,%val)=%s_diff -> coopmatrix<f32x32x16,matrix_acc> {
                    %expval = native_exp2 %val : f32
                    yield (%expval)
                }

                %maxvec_diff = sub %maxvec_iter, %maxvec_next : coopmatrix<f32x1x16,matrix_acc>
                %maxvec_diff_exp = cooperative_matrix_apply (%x,%y,%val)=%maxvec_diff
                                        -> coopmatrix<f32x1x16,matrix_acc> {
                    %expval = native_exp2 %val : f32
                    yield (%expval)
                }
                %normvec_rescaled = mul %maxvec_diff_exp, %normvec_iter : coopmatrix<f32x1x16,matrix_acc>
                %p_red = cooperative_matrix_reduce_add.column %p : coopmatrix<f32x1x16,matrix_acc>
                %normvec_next = add %normvec_rescaled, %p_red : coopmatrix<f32x1x16,matrix_acc>

                %maxvec_diff_exp_b = cast %maxvec_diff_exp : coopmatrix<f32x1x16,matrix_b>
                %maxvec_mat = cooperative_matrix_mul_add %ones, %maxvec_diff_exp_b, %o_init : coopmatrix<f32x32x16,matrix_acc>

                %p_b = cast %p : coopmatrix<$dtype x32x16,matrix_b>
                %vv1 = cooperative_matrix_load.cols_checked %v[%c0,%n] : coopmatrix<$dtype x32x32,matrix_a>
                %vv2 = cooperative_matrix_load.cols_checked %v[%c32,%n] : coopmatrix<$dtype x32x32,matrix_a>
                %o_rescaled1 = mul %maxvec_mat, %o_iter1 : coopmatrix<f32x32x16,matrix_acc>
                %o_next1 = cooperative_matrix_mul_add %vv1, %p_b, %o_rescaled1 : coopmatrix<f32x32x16,matrix_acc>
                %o_rescaled2 = mul %maxvec_mat, %o_iter2 : coopmatrix<f32x32x16,matrix_acc>
                %o_next2 = cooperative_matrix_mul_add %vv2, %p_b, %o_rescaled2 : coopmatrix<f32x32x16,matrix_acc>
                yield (%o_next1,%o_next2,%maxvec_next,%normvec_next)
            }
            %ones16 = constant 1.0 : coopmatrix<f32x1x16,matrix_acc>
            %normvec_inv = div %ones16, %normvec : coopmatrix<f32x1x16,matrix_acc>
            %normvec_inv_b = cast %normvec_inv : coopmatrix<f32x1x16,matrix_b>
            %normvec_inv_mat = cooperative_matrix_mul_add %ones, %normvec_inv_b, %o_init : coopmatrix<f32x32x16,matrix_acc>
            %o_scaled1 = mul %normvec_inv_mat, %o_acc1 : coopmatrix<f32x32x16,matrix_acc>
            %o_scaled2 = mul %normvec_inv_mat, %o_acc2 : coopmatrix<f32x32x16,matrix_acc>
            %o_scaled1_f16 = cast %o_scaled1 : coopmatrix<$dtype x32x16,matrix_acc>
            cooperative_matrix_store.cols_checked %o_scaled1_f16, %o[%c0,%j]
            %o_scaled2_f16 = cast %o_scaled2 : coopmatrix<$dtype x32x16,matrix_acc>
            cooperative_matrix_store.cols_checked %o_scaled2_f16, %o[%c32,%j]
        } attributes{unroll=false}
    }
}
