; Copyright (C) 2024 Intel Corporation
; SPDX-License-Identifier: BSD-3-Clause

; RUN: %tinytc-opt -pdump-matrix-ext < %s | filecheck %s

func @basic(%A: memref<f16x64x64>) subgroup_size(16) {
    %z = constant 0 : index
    %0 = cooperative_matrix_load.n %A[%z,%z], align 32 : coopmatrix<f16x16x16,matrix_a>
    %1 = cooperative_matrix_load.n %A[%z,%z], align 32 : coopmatrix<f16x16x8,matrix_b>
    %2 = constant 0.0 : coopmatrix<f32x16x8,matrix_acc>
    %3 = cooperative_matrix_mul_add %0, %1, %2 : coopmatrix<f16x16x8,matrix_acc>
    cooperative_matrix_store %3, %A[%z,%z]
    %4 = constant 0.0 : coopmatrix<f16x42x13,matrix_acc>
; CHECK-LABEL: Matrix extension in @basic
; CHECK: matrix_ext(%0) = 1
; CHECK: matrix_ext(%1) = 1
; CHECK: matrix_ext(%2) = 1
; CHECK: matrix_ext(%3) = 1
; CHECK: matrix_ext(%4) = 0
}

func @if(%A: memref<f16x64x64>) subgroup_size(16) {
    %0 = constant true : bool
    %1 = if %0 -> (coopmatrix<f16x16x16,matrix_a>) {
        %2 = constant 42.0 : coopmatrix<f16x16x16,matrix_a>
        yield (%2)
    } else {
        %3 = constant 0.0 : coopmatrix<f16x16x16,matrix_a>
        yield (%3)
    }
    %4 = if %0 -> (coopmatrix<f16x16x8,matrix_acc>) {
        %z = constant 0 : index
        ; transpose not supported -> cannot use matrix extension on PVC
        %5 = cooperative_matrix_load.t %A[%z,%z] : coopmatrix<f16x16x8,matrix_acc>
        yield (%5)
    } else {
        %6 = constant 0.0 : coopmatrix<f16x16x8,matrix_acc>
        yield (%6)
    }
; CHECK-LABEL: Matrix extension in @if
; CHECK: matrix_ext(%1) = 1
; CHECK: matrix_ext(%2) = 1
; CHECK: matrix_ext(%3) = 1
; CHECK: matrix_ext(%4) = 0
; CHECK: matrix_ext(%5) = 0
; CHECK: matrix_ext(%6) = 0
}

func @for1(%A: memref<f16x16x16> align(64),
          %B: memref<f16x16x8> align(64),
          %C: memref<f32x16x8> align(64)) subgroup_size(16) {
    %z = constant 0 : index
    %0 = constant 0x0p+0 : coopmatrix<f32x16x8,matrix_acc>
    %1 = constant 0 : index
    %2 = constant 16 : index
    %3 = constant 8 : index
    %4 = for %5:index=%1,%2,%3 init(%6=%0) -> (coopmatrix<f32x16x8,matrix_acc>) {
        %7 = cooperative_matrix_load.n %A[%5,%z], align 32 : coopmatrix<f16x16x16,matrix_a>
        %8 = cooperative_matrix_load.n %B[%z,%z], align 16 : coopmatrix<f16x16x8,matrix_b>
        %9 = cooperative_matrix_mul_add %7, %8, %6 : coopmatrix<f32x16x8,matrix_acc>
        yield (%9)
    }
    cooperative_matrix_store %4, %C[%z,%z], align 32
; CHECK-LABEL: Matrix extension in @for1
; CHECK: matrix_ext(%0) = 1
; CHECK: matrix_ext(%6) = 1
; CHECK: matrix_ext(%5) = 1
; CHECK: matrix_ext(%7) = 1
; CHECK: matrix_ext(%8) = 1
; CHECK: matrix_ext(%9) = 1
}

func @for2(%A: memref<f16x16x16> align(64),
          %B: memref<f16x16x8> align(64),
          %C: memref<f32x16x8> align(64)) subgroup_size(16) {
    %z = constant 0 : index
    %0 = constant 0x0p+0 : coopmatrix<f32x16x8,matrix_acc>
    %1 = constant 0 : index
    %2 = constant 16 : index
    %3 = constant 8 : index
    %4 = for %5:index=%1,%2,%3 init(%6=%0) -> (coopmatrix<f32x16x8,matrix_acc>) {
        %7 = cooperative_matrix_load.n %A[%5,%z], align 32 : coopmatrix<f16x16x16,matrix_a>
        %8 = cooperative_matrix_load.n %B[%z,%z], align 16 : coopmatrix<f16x16x8,matrix_b>
        %9 = cooperative_matrix_mul_add %7, %8, %6 : coopmatrix<f32x16x8,matrix_acc>
        yield (%9)
    }
    %10 = constant 1.0 : coopmatrix<f16x16x11,matrix_a>
    %11 = constant 2.0 : coopmatrix<f16x11x8,matrix_b>
    %12 = cooperative_matrix_mul_add %10, %11, %4 : coopmatrix<f32x16x8,matrix_acc>
    cooperative_matrix_store %12, %C[%z,%z], align 32
; CHECK-LABEL: Matrix extension in @for2
; CHECK: matrix_ext(%0) = 0
; CHECK: matrix_ext(%6) = 0
; CHECK: matrix_ext(%5) = 0
; CHECK: matrix_ext(%7) = 0
; CHECK: matrix_ext(%8) = 0
; CHECK: matrix_ext(%9) = 0
; CHECK: matrix_ext(%10) = 0
; CHECK: matrix_ext(%11) = 0
; CHECK: matrix_ext(%12) = 0
}

func @unsupported_loads(%A: memref<f16x32x16>, %B: memref<f16x33x16>) subgroup_size(16) {
    %z = constant 0 : index
    %c1 = constant 1 : index
    ; Load not 4 byte aligned
    %0 = cooperative_matrix_load.n %A[%z,%z] : coopmatrix<f16x16x16,matrix_a>
    ; Transpose unsupported
    %1 = cooperative_matrix_load.t %A[%z,%z] : coopmatrix<f16x16x16,matrix_a>
    ; Offset not 4 byte aligned
    %2 = cooperative_matrix_load.n %A[%c1,%z], align 4 : coopmatrix<f16x16x16,matrix_a>
    ; Stride not 8 byte aligned
    %3 = cooperative_matrix_load.n %B[%z,%z], align 4 : coopmatrix<f16x16x16,matrix_a>

    ; Base stride not 64 byte aligned when checked
    %4 = cooperative_matrix_load.n %A[%z,%z], align 4 : coopmatrix<f16x16x16,matrix_a>
    %5 = cooperative_matrix_load.n.rows_checked %A[%z,%z], align 4 : coopmatrix<f16x16x16,matrix_a>
; CHECK-LABEL: Matrix extension in @unsupported_loads
; CHECK: matrix_ext(%0) = 0
; CHECK: matrix_ext(%1) = 0
; CHECK: matrix_ext(%2) = 0
; CHECK: matrix_ext(%3) = 0
; CHECK: matrix_ext(%4) = 1
; CHECK: matrix_ext(%5) = 0
}
