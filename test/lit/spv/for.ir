; Copyright (C) 2024 Intel Corporation
; SPDX-License-Identifier: BSD-3-Clause

; CHECK: %[[#I16:]] = OpTypeInt 16 0
; CHECK: %[[#I16_C0:]] = OpConstant %[[#I16]] 0
; CHECK: %[[#I16_C10:]] = OpConstant %[[#I16]] 10
; CHECK: %[[#I16_C2:]] = OpConstant %[[#I16]] 2
; CHECK: %[[#BOOL:]] = OpTypeBool
; CHECK: %[[#I32:]] = OpTypeInt 32 0
; CHECK: %[[#I32_C2:]] = OpConstant %[[#I32]] 2
; CHECK: %[[#I32_C6:]] = OpConstant %[[#I32]] 6
; CHECK: %[[#I64:]] = OpTypeInt 64 0
; CHECK: %[[#I64_C0:]] = OpConstant %[[#I64]] 0
; CHECK: %[[#I64_C1:]] = OpConstant %[[#I64]] 1
; CHECK: %[[#I32_C1:]] = OpConstant %[[#I32]] 1
; CHECK: %[[#I16_C6:]] = OpConstant %[[#I16]] 6
; CHECK: %[[#I16_C1:]] = OpConstant %[[#I16]] 1

; RUN: %tinytc-oc -S -O0 < %s | filecheck %s
func @for1() {
  %lb = constant 0 : i16
  %ub = constant 10 : i16
  %step = constant 2 : i16
  for %0:i16 = %lb,%ub,%step {
  }
; CHECK-LABEL:                %[[#]] = OpFunction {{.*}}
; CHECK:         %[[#ENTRY_LABEL1:]] = OpLabel
; CHECK-NEXT:                          OpBranch %[[#HEAD_LABEL1:]]
; CHECK-NEXT:      %[[#HEAD_LABEL1]] = OpLabel
; CHECK-NEXT:       %[[#LOOP_VAR1:]] = OpPhi %[[#I16]] %[[#I16_C0]] %[[#ENTRY_LABEL1]] %[[#LOOP_VAR_UPDATE1:]] %[[#CONT_LABEL1:]]
; CHECK-NEXT:    %[[#CONDITION1_1:]] = OpSLessThan %[[#BOOL]] %[[#LOOP_VAR1]] %[[#I16_C10]]
; CHECK-NEXT:                          OpLoopMerge %[[#MERGE_LABEL1:]] %[[#CONT_LABEL1:]] None
; CHECK-NEXT:                          OpBranchConditional %[[#CONDITION1_1]] %[[#BODY_LABEL1:]] %[[#MERGE_LABEL1:]]
; CHECK-NEXT:      %[[#BODY_LABEL1]] = OpLabel
; CHECK-NEXT:                          OpBranch %[[#CONT_LABEL1]]
; CHECK-NEXT:      %[[#CONT_LABEL1]] = OpLabel
; CHECK-NEXT: %[[#LOOP_VAR_UPDATE1]] = OpIAdd %[[#I16]] %[[#LOOP_VAR1]] %[[#I16_C2]]
; CHECK-NEXT:                          OpBranch %[[#HEAD_LABEL1]]
; CHECK-NEXT:     %[[#MERGE_LABEL1]] = OpLabel
}

func @for2() {
  %from = constant 2 : i32
  %to = constant 6 : i32
  %f0 = constant 0 : i64
  %f1 = constant 1 : i64
  %fn_1, %fn = for %n:i32=%from,%to init(%fn_2=%f0,%fn_1=%f1) -> (i64,i64) {
    %fn = arith.add %fn_2, %fn_1 : i64
    yield (%fn_1, %fn)
  }
  %neg_fn = arith.neg %fn : i64
; CHECK-LABEL:                %[[#]] = OpFunction {{.*}}
; CHECK:         %[[#ENTRY_LABEL2:]] = OpLabel
; CHECK-NEXT:                          OpBranch %[[#HEAD_LABEL2:]]
; CHECK-NEXT:      %[[#HEAD_LABEL2]] = OpLabel
; CHECK-NEXT:       %[[#LOOP_VAR2:]] = OpPhi %[[#I32]] %[[#I32_C2]] %[[#ENTRY_LABEL2]] %[[#LOOP_VAR_UPDATE2:]] %[[#CONT_LABEL2:]]
; CHECK-NEXT:          %[[#PHI2_1:]] = OpPhi %[[#I64]] %[[#I64_C0]] %[[#ENTRY_LABEL2]] %[[#PHI2_2:]] %[[#CONT_LABEL2]]
; CHECK-NEXT:           %[[#PHI2_2]] = OpPhi %[[#I64]] %[[#I64_C1]] %[[#ENTRY_LABEL2]] %[[#FN_UPDATE2:]] %[[#CONT_LABEL2]]
; CHECK-NEXT:    %[[#CONDITION2_1:]] = OpSLessThan %[[#BOOL]] %[[#LOOP_VAR2]] %[[#I32_C6]]
; CHECK-NEXT:                          OpLoopMerge %[[#MERGE_LABEL2:]] %[[#CONT_LABEL2:]] None
; CHECK-NEXT:                          OpBranchConditional %[[#CONDITION2_1]] %[[#BODY_LABEL2:]] %[[#MERGE_LABEL2]]
; CHECK-NEXT:      %[[#BODY_LABEL2]] = OpLabel
; CHECK-NEXT:       %[[#FN_UPDATE2]] = OpIAdd %[[#I64]] %[[#PHI2_1]] %[[#PHI2_2]]
; CHECK-NEXT:                          OpBranch %[[#CONT_LABEL2]]
; CHECK-NEXT:      %[[#CONT_LABEL2]] = OpLabel
; CHECK-NEXT: %[[#LOOP_VAR_UPDATE2]] = OpIAdd %[[#I32]] %[[#LOOP_VAR2]] %[[#I32_C1]]
; CHECK-NEXT:                          OpBranch %[[#HEAD_LABEL2]]
; CHECK-NEXT:     %[[#MERGE_LABEL2]] = OpLabel
; CHECK-NEXT:                 %[[#]] = OpSNegate %[[#I64]] %[[#PHI2_2]]
}

func @for3() subgroup_size(16) {
  %from = constant 2 : i16
  %to = constant 6 : i16
  %m_init = constant 1 : coopmatrix<i16x16x4,matrix_acc>
  %m = for %n:i16=%from,%to init(%m_iter=%m_init) -> (coopmatrix<i16x16x4,matrix_acc>) {
    %m_update = arith.add %m_iter, %m_init : coopmatrix<i16x16x4,matrix_acc>
    yield (%m_update)
  }
  %neg_m = arith.neg %m : coopmatrix<i16x16x4,matrix_acc>
; CHECK-LABEL:                %[[#]] = OpFunction {{.*}}
; CHECK:         %[[#ENTRY_LABEL3:]] = OpLabel
; CHECK-NEXT:                          OpBranch %[[#HEAD_LABEL3:]]
; CHECK-NEXT:      %[[#HEAD_LABEL3]] = OpLabel
; CHECK-NEXT:       %[[#LOOP_VAR3:]] = OpPhi %[[#I16]] %[[#I16_C2]] %[[#ENTRY_LABEL3]] %[[#LOOP_VAR_UPDATE3:]] %[[#CONT_LABEL3:]]
; CHECK-NEXT:          %[[#PHI3_1:]] = OpPhi %[[#I16]] %[[#I16_C1]] %[[#ENTRY_LABEL3]] %[[#PHI_UPDATE3_1:]] %[[#CONT_LABEL3]]
; CHECK-NEXT:          %[[#PHI3_2:]] = OpPhi %[[#I16]] %[[#I16_C1]] %[[#ENTRY_LABEL3]] %[[#PHI_UPDATE3_2:]] %[[#CONT_LABEL3]]
; CHECK-NEXT:          %[[#PHI3_3:]] = OpPhi %[[#I16]] %[[#I16_C1]] %[[#ENTRY_LABEL3]] %[[#PHI_UPDATE3_3:]] %[[#CONT_LABEL3]]
; CHECK-NEXT:          %[[#PHI3_4:]] = OpPhi %[[#I16]] %[[#I16_C1]] %[[#ENTRY_LABEL3]] %[[#PHI_UPDATE3_4:]] %[[#CONT_LABEL3]]
; CHECK-NEXT:    %[[#CONDITION3_1:]] = OpSLessThan %[[#BOOL]] %[[#LOOP_VAR3]] %[[#I16_C6]]
; CHECK-NEXT:                          OpLoopMerge %[[#MERGE_LABEL3:]] %[[#CONT_LABEL3:]] None
; CHECK-NEXT:                          OpBranchConditional %[[#CONDITION3_1]] %[[#BODY_LABEL3:]] %[[#MERGE_LABEL3]]
; CHECK-NEXT:      %[[#BODY_LABEL3]] = OpLabel
; CHECK-NEXT:   %[[#PHI_UPDATE3_1:]] = OpIAdd %[[#I16]] %[[#PHI3_1]] %[[#I16_C1]]
; CHECK-NEXT:   %[[#PHI_UPDATE3_2:]] = OpIAdd %[[#I16]] %[[#PHI3_2]] %[[#I16_C1]]
; CHECK-NEXT:   %[[#PHI_UPDATE3_3:]] = OpIAdd %[[#I16]] %[[#PHI3_3]] %[[#I16_C1]]
; CHECK-NEXT:   %[[#PHI_UPDATE3_4:]] = OpIAdd %[[#I16]] %[[#PHI3_4]] %[[#I16_C1]]
; CHECK-NEXT:                          OpBranch %[[#CONT_LABEL3]]
; CHECK-NEXT:      %[[#CONT_LABEL3]] = OpLabel
; CHECK-NEXT: %[[#LOOP_VAR_UPDATE3]] = OpIAdd %[[#I16]] %[[#LOOP_VAR3]] %[[#I16_C1]]
; CHECK-NEXT:                          OpBranch %[[#HEAD_LABEL3]]
; CHECK-NEXT:     %[[#MERGE_LABEL3]] = OpLabel
; CHECK-NEXT:                 %[[#]] = OpSNegate %[[#I16]] %[[#PHI3_1]]
; CHECK-NEXT:                 %[[#]] = OpSNegate %[[#I16]] %[[#PHI3_2]]
; CHECK-NEXT:                 %[[#]] = OpSNegate %[[#I16]] %[[#PHI3_3]]
; CHECK-NEXT:                 %[[#]] = OpSNegate %[[#I16]] %[[#PHI3_4]]
}

func @for4() {
  %lb = constant 0 : i16
  %ub = constant 10 : i16
  for %0:i16 = %lb,%ub {
  }.unroll(1)
  for %1:i16 = %lb,%ub {
  }.unroll(2)
  for %2:i16 = %lb,%ub {
  }.unroll
; CHECK-LABEL:                %[[#]] = OpFunction {{.*}}
; CHECK:                               OpLoopMerge %[[#]] %[[#]] DontUnroll
; CHECK:                               OpLoopMerge %[[#]] %[[#]] PartialCount 2
; CHECK:                               OpLoopMerge %[[#]] %[[#]] Unroll
}
