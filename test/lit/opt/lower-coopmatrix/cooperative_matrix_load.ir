; Copyright (C) 2024 Intel Corporation
; SPDX-License-Identifier: BSD-3-Clause

; RUN: %tinytc-opt -plower-coopmatrix < %s | filecheck %s

func @coopmatrix_a_load_n(%A: memref<i32x64x48>, %x: index, %y: index) attributes{subgroup_size=16} {
    parallel {
        %0 = cooperative_matrix_load.n %A[%x,%y] : coopmatrix<i32x16x3,matrix_a>
    }
; CHECK-LABEL: func @coopmatrix_a_load_n({{.*}}
; CHECK:      %0 = builtin.subgroup_local_id : i32
; CHECK-NEXT: %1 = cast %0 : index
; CHECK-NEXT: %2 = arith.add %x, %1 : index
; CHECK-NEXT: %3 = subview %A[%2,%y:3] : memref<i32x3,strided<64>>
; CHECK-NEXT: %4 = constant 0 : index
; CHECK-NEXT: %5 = load %3[%4] : i32
; CHECK-NEXT: %6 = constant 1 : index
; CHECK-NEXT: %7 = load %3[%6] : i32
; CHECK-NEXT: %8 = constant 2 : index
; CHECK-NEXT: %9 = load %3[%8] : i32
}

func @coopmatrix_a_load_n_rows_checked(%A: memref<i32x64x48>, %x: index, %y: index) attributes{subgroup_size=16} {
    parallel {
        %0 = cooperative_matrix_load.n.rows_checked %A[%x,%y] : coopmatrix<i32x32x2,matrix_a>
    }
; CHECK-LABEL: func @coopmatrix_a_load_n_rows_checked({{.*}}
; CHECK:      %0 = builtin.subgroup_local_id : i32
; CHECK-NEXT: %1 = cast %0 : index
; CHECK-NEXT: %2 = arith.add %x, %1 : index
; CHECK-NEXT: %3 = subview %A[%2,%y:2] : memref<i32x2,strided<64>>
; CHECK-NEXT: %4 = size %A[0] : index
; CHECK-NEXT: %5 = arith.sub %4, %x : index
; CHECK-NEXT: %6 = arith.neg %1 : index
; CHECK-NEXT: %7 = cmp.le %6, %x : bool
; CHECK-NEXT: %8 = cmp.lt %1, %5 : bool
; CHECK-NEXT: %9 = arith.and %7, %8 : bool
; CHECK-NEXT: %10 = constant 0 : index
; CHECK-NEXT: %11 = constant 1 : index
; CHECK-NEXT: %12,%13 = if %9 -> (i32,i32) {
; CHECK-NEXT:   %14 = load %3[%10] : i32
; CHECK-NEXT:   %15 = load %3[%11] : i32
; CHECK-NEXT:   yield (%14, %15)
; CHECK-NEXT: } else {
; CHECK-NEXT:   %16 = constant 0 : i32
; CHECK-NEXT:   yield (%16, %16)
; CHECK-NEXT: }
; CHECK-NEXT: %17 = constant 16 : index
; CHECK-NEXT: %18 = arith.add %x, %17 : index
; CHECK-NEXT: %19 = arith.add %18, %1 : index
; CHECK-NEXT: %20 = subview %A[%19,%y:2] : memref<i32x2,strided<64>>
; CHECK-NEXT: %21 = size %A[0] : index
; CHECK-NEXT: %22 = arith.sub %21, %18 : index
; CHECK-NEXT: %23 = arith.neg %1 : index
; CHECK-NEXT: %24 = cmp.le %23, %18 : bool
; CHECK-NEXT: %25 = cmp.lt %1, %22 : bool
; CHECK-NEXT: %26 = arith.and %24, %25 : bool
; CHECK-NEXT: %27 = constant 0 : index
; CHECK-NEXT: %28 = constant 1 : index
; CHECK-NEXT: %29,%30 = if %26 -> (i32,i32) {
; CHECK-NEXT:   %31 = load %20[%27] : i32
; CHECK-NEXT:   %32 = load %20[%28] : i32
; CHECK-NEXT:   yield (%31, %32)
; CHECK-NEXT: } else {
; CHECK-NEXT:   %33 = constant 0 : i32
; CHECK-NEXT:   yield (%33, %33)
; CHECK-NEXT: }
}

func @coopmatrix_a_load_n_cols_checked(%A: memref<i32x64x48>, %x: index, %y: index) attributes{subgroup_size=16} {
    parallel {
        %0 = cooperative_matrix_load.n.cols_checked %A[%x,%y] : coopmatrix<i32x16x2,matrix_a>
    }
; CHECK-LABEL: func @coopmatrix_a_load_n_cols_checked({{.*}}
; CHECK:       %0 = builtin.subgroup_local_id : i32
; CHECK-NEXT:  %1 = cast %0 : index
; CHECK-NEXT:  %2 = arith.add %x, %1 : index
; CHECK-NEXT:  %3 = subview %A[%2,%y:2] : memref<i32x2,strided<64>>
; CHECK-NEXT:  %4 = constant 0 : index
; CHECK-NEXT:  %5 = size %A[1] : index
; CHECK-NEXT:  %6 = arith.sub %5, %y : index
; CHECK-NEXT:  %7 = arith.neg %4 : index
; CHECK-NEXT:  %8 = cmp.le %7, %y : bool
; CHECK-NEXT:  %9 = cmp.lt %4, %6 : bool
; CHECK-NEXT:  %10 = arith.and %8, %9 : bool
; CHECK-NEXT:  %11 = if %10 -> (i32) {
; CHECK-NEXT:    %12 = load %3[%4] : i32
; CHECK-NEXT:    yield (%12)
; CHECK-NEXT:  } else {
; CHECK-NEXT:    %13 = constant 0 : i32
; CHECK-NEXT:    yield (%13)
; CHECK-NEXT:  }
; CHECK-NEXT:  %14 = constant 1 : index
; CHECK-NEXT:  %15 = arith.neg %14 : index
; CHECK-NEXT:  %16 = cmp.le %15, %y : bool
; CHECK-NEXT:  %17 = cmp.lt %14, %6 : bool
; CHECK-NEXT:  %18 = arith.and %16, %17 : bool
; CHECK-NEXT:  %19 = if %18 -> (i32) {
; CHECK-NEXT:    %20 = load %3[%14] : i32
; CHECK-NEXT:    yield (%20)
; CHECK-NEXT:  } else {
; CHECK-NEXT:    %21 = constant 0 : i32
; CHECK-NEXT:    yield (%21)
; CHECK-NEXT:  }
}

func @coopmatrix_a_load_t(%A: memref<i32x64x48>, %x: index, %y: index) attributes{subgroup_size=16} {
    parallel {
        %0 = cooperative_matrix_load.t %A[%x,%y] : coopmatrix<i32x16x2,matrix_a>
    }
; CHECK-LABEL: func @coopmatrix_a_load_t({{.*}}
; CHECK:       %0 = builtin.subgroup_local_id : i32
; CHECK-NEXT:  %1 = cast %0 : index
; CHECK-NEXT:  %2 = arith.add %y, %1 : index
; CHECK-NEXT:  %3 = subview %A[%x:2,%2] : memref<i32x2>
; CHECK-NEXT:  %4 = constant 0 : index
; CHECK-NEXT:  %5 = load %3[%4] : i32
; CHECK-NEXT:  %6 = constant 1 : index
; CHECK-NEXT:  %7 = load %3[%6] : i32
}
