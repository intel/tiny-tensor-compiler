; Copyright (C) 2024 Intel Corporation
; SPDX-License-Identifier: BSD-3-Clause

; RUN: %tinytc-opt -pdead-code-elimination < %s | filecheck %s
func @dead_if(%a: memref<f64>) {
    %cfalse = constant false : bool
    if %cfalse {
        %c42 = constant 42.0 : f64
        store %c42, %a[]
    }
    if %cfalse {
        %c43 = constant 43.0 : f64
        store %c43, %a[]
    } else {
        %c44 = constant 44.0 : f64
        store %c44, %a[]
    }
    %ctrue = constant true : bool
    if %ctrue {
        %c45 = constant 43.0 : f64
        store %c45, %a[]
    }
; CHECK-LABEL: func @dead_if({{.*}}
; CHECK-NEXT: %c44 = {{.*}}
; CHECK-NEXT: store %c44, %a[]
; CHECK-NEXT: %c45 = {{.*}}
; CHECK-NEXT: store %c45, %a[]
}

func @dead_if_with_yield(%a: memref<f64>) {
    %ctrue = constant true : bool
    %cfalse = constant false : bool
    %tmp = if %cfalse -> (f64) {
        %c42 = constant 42.0 : f64
        yield (%c42)
    } else {
        %1,%2 = if %ctrue -> (f64,f64) {
            %c44 = constant 44.0 : f64
            %c45 = constant 45.0 : f64
            yield (%c44,%c45)
        } else {
            %c46 = constant 46.0 : f64
            %c47 = constant 47.0 : f64
            yield (%c46,%c47)
        }
        %3 = add %1, %2 : f64
        yield (%3)
    }
    store %tmp, %a[]
; Cannot eliminate if that returns results currently
; CHECK-LABEL: func @dead_if_with_yield({{.*}}
; CHECK-NEXT: %c44 = {{.*}}
; CHECK-NEXT: %c45 = {{.*}}
; CHECK-NEXT: %0 = add %c44, %c45 : f64
; CHECK-NEXT: store %0, %a[]
}

func @dead_loop(%a: memref<f64>) {
    %c2 = constant 2 : index
    for %0=%c2,%c2 {
        %c42 = constant 42.0 : f64
        store %c42, %a[]
    }
    %c5 = constant 5 : index
    %c6 = constant 6 : index
    for %0=%c5,%c6 {
        %c43 = constant 43.0 : f64
        store %c43, %a[]
    }
; CHECK-LABEL: func @dead_loop({{.*}}
; CHECK-NEXT: %c5 = constant 5 : index
; CHECK-NEXT: %c6 = constant 6 : index
; CHECK-NEXT: for %0=%c5,%c6 {
; CHECK-NEXT:   %c43{{.*}}
; CHECK-NEXT:   store{{.*}}
; CHECK-NEXT: }
}

func @unused_alloca(%a: memref<f64x4>) {
    %0 = alloca : memref<f64x8,local>
    %1 = alloca : memref<f64x4,local>
    %one = constant 1.0 : f64
    axpby %one, %1, %one, %a
; CHECK-LABEL: func @unused_alloca({{.*}}
; CHECK-NEXT: %0 = alloca : memref<f64x4,local>
; CHECK-NEXT: %one{{.*}}
; CHECK-NEXT: axpby %one, %0{{.*}}
}
