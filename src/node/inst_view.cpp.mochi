// Copyright (C) 2025 Intel Corporation
// SPDX-License-Identifier: BSD-3-Clause

#include "node/inst_view.hpp"
#include "scalar_type.hpp"
#include "util/casting.hpp"

namespace tinytc {

template <typename T> void safe_increase(std::int32_t &value, T by) {
    if (by < 0 || by > std::numeric_limits<std::int32_t>::max() - value) {
        throw status::out_of_range;
    }
    value += by;
}

// もち inst_cpp "tinytc/instructions.anko"

coopmatrix_data_type *get_coopmatrix_type(location const &loc, tinytc_value const &v) {
    auto m = dyn_cast<coopmatrix_data_type>(v.ty());
    if (m == nullptr) {
        throw compilation_error(loc, {&v}, status::ir_expected_coopmatrix);
    }
    return m;
}

scalar_data_type *get_scalar_type(location const &loc, tinytc_value const &v) {
    auto m = dyn_cast<scalar_data_type>(v.ty());
    if (m == nullptr) {
        throw compilation_error(loc, {&v}, status::ir_expected_scalar);
    }
    return m;
}

memref_data_type *get_memref_type(location const &loc, tinytc_value const &v) {
    auto m = dyn_cast<memref_data_type>(v.ty());
    if (m == nullptr) {
        throw compilation_error(loc, {&v}, status::ir_expected_memref);
    }
    return m;
}

void check_index_ty(location const &loc, tinytc_value const &v) {
    if (auto sty = dyn_cast<scalar_data_type>(v.ty()); !sty || sty->ty() != scalar_type::index) {
        throw compilation_error(loc, {&v}, status::ir_expected_index);
    }
}

void check_memref_shape(memref_data_type *rt, std::int64_t ri, memref_data_type *ot,
                        std::int64_t oi, location const &loc) {
    if (rt->shape(ri) != ot->shape(oi)) {
        auto extra_info = std::ostringstream{} << "Size of mode " << ri
                                               << " does not match operand mode " << oi << " ["
                                               << rt->shape(ri) << "!=" << ot->shape(oi) << "]";
        throw compilation_error(loc, status::ir_invalid_shape, std::move(extra_info).str());
    }
}
void check_memref_stride(memref_data_type *rt, std::int64_t ri, memref_data_type *ot,
                         std::int64_t oi, location const &loc) {
    if (!is_dynamic_value(rt->stride(ri)) && rt->stride(ri) != ot->stride(oi)) {
        auto extra_info = std::ostringstream{} << "Stride of mode " << ri
                                               << " does not match operand stride " << oi << " ["
                                               << rt->stride(ri) << "!=" << ot->stride(oi) << "]";
        throw compilation_error(loc, status::ir_invalid_stride, std::move(extra_info).str());
    }
}

void check_memref_mode(memref_data_type *rt, std::int64_t ri, memref_data_type *ot, std::int64_t oi,
                       location const &loc) {
    check_memref_shape(rt, ri, ot, oi, loc);
    check_memref_stride(rt, ri, ot, oi, loc);
}

auto get_and_check_memref_type_addrspace(tinytc_value const &operand, tinytc_data_type_t ty,
                                         location const &loc)
    -> std::pair<memref_data_type *, memref_data_type *> {
    auto rt = dyn_cast<memref_data_type>(ty);
    if (!rt) {
        throw compilation_error(loc, status::ir_expected_memref);
    }
    auto ot = get_memref_type(loc, operand);
    if (rt->element_data_ty() != ot->element_data_ty()) {
        throw compilation_error(loc, {&operand}, status::ir_scalar_mismatch);
    }
    if (rt->addrspace() != ot->addrspace()) {
        throw compilation_error(loc, {&operand}, status::ir_address_space_mismatch);
    }
    return {ot, rt};
}

void blas_a2_inst::check() {
    auto At = get_memref_type(loc(), A());
    auto Bt = get_memref_type(loc(), B());
    auto alphat = get_scalar_type(loc(), alpha());
    auto betat = get_scalar_type(loc(), beta());

    if (!promotable(alphat->ty(), At->element_ty())) {
        throw compilation_error(loc(), {&alpha(), &A()}, status::ir_forbidden_promotion);
    }
    if (!promotable(At->element_ty(), Bt->element_ty())) {
        throw compilation_error(loc(), {&A(), &B()}, status::ir_forbidden_promotion);
    }
    if (!promotable(betat->ty(), Bt->element_ty())) {
        throw compilation_error(loc(), {&beta(), &B()}, status::ir_forbidden_promotion);
    }
}

void blas_a3_inst::check() {
    auto At = get_memref_type(loc(), A());
    auto Bt = get_memref_type(loc(), B());
    auto Ct = get_memref_type(loc(), C());
    auto alphat = get_scalar_type(loc(), alpha());
    auto betat = get_scalar_type(loc(), beta());

    const auto AB_ty = promote(At->element_ty(), Bt->element_ty());
    if (!AB_ty) {
        throw compilation_error(loc(), {&A(), &B()}, status::ir_forbidden_promotion);
    }
    if (!promotable(alphat->ty(), *AB_ty)) {
        throw compilation_error(loc(), {&alpha(), &A(), &B()}, status::ir_forbidden_promotion);
    }
    if (!promotable(*AB_ty, Ct->element_ty())) {
        throw compilation_error(loc(), {&A(), &B(), &C()}, status::ir_forbidden_promotion);
    }
    if (!promotable(betat->ty(), Ct->element_ty())) {
        throw compilation_error(loc(), {&beta(), &C()}, status::ir_forbidden_promotion);
    }
}

void alloca_inst::check() {
    auto memref = dyn_cast<memref_data_type>(result().ty());
    if (memref == nullptr) {
        throw compilation_error(loc(), status::ir_expected_memref);
    }
    if (memref->addrspace() != address_space::local) {
        throw compilation_error(loc(), status::ir_expected_local_address_space);
    }
}

void axpby_inst::check() {
    auto a = get_memref_type(loc(), A());
    auto b = get_memref_type(loc(), B());

    if (b->dim() < 0 || b->dim() > 2) {
        throw compilation_error(loc(), {&B()}, status::ir_expected_memref_order_0_1_or_2);
    }

    bool shape_equal = false;
    if (tA() == transpose::T && a->dim() == 2 && b->dim() == 2) {
        shape_equal = a->shape()[1] == b->shape()[0] && a->shape()[0] == b->shape()[1];
    } else {
        shape_equal = a->shape() == b->shape();
    }

    if (!shape_equal) {
        throw compilation_error(loc(), {&A(), &B()}, status::ir_incompatible_shapes);
    }
}

void arith_inst::check() {
    auto ty = result().ty();

    if (a().ty() != ty) {
        throw compilation_error(loc(), {&a()}, status::ir_operand_type_must_match_return_type);
    }
    if (b().ty() != ty) {
        throw compilation_error(loc(), {&b()}, status::ir_operand_type_must_match_return_type);
    }

    if (isa<boolean_data_type>(*ty)) {
        auto const inst_supports_bool = [&] {
            switch (operation) {
            case arithmetic::and_:
            case arithmetic::or_:
            case arithmetic::xor_:
                return true;
            default:
                return false;
            }
        }();
        if (!inst_supports_bool) {
            throw compilation_error(loc(), status::ir_boolean_unsupported);
        }
    } else {
        auto const check_scalar_ty = [&](scalar_type sty) {
            bool inst_supports_fp = true;
            bool inst_supports_complex = true;
            switch (operation) {
            case arithmetic::add:
            case arithmetic::sub:
            case arithmetic::mul:
            case arithmetic::div:
                break;
            case arithmetic::min:
            case arithmetic::max:
            case arithmetic::rem:
                inst_supports_complex = false;
                break;
            case arithmetic::and_:
            case arithmetic::or_:
            case arithmetic::xor_:
                inst_supports_fp = false;
                inst_supports_complex = false;
                break;
            case arithmetic::shl:
            case arithmetic::shr:
                inst_supports_fp = false;
                inst_supports_complex = false;
                break;
            }
            if (!inst_supports_fp && is_floating_type(sty)) {
                throw compilation_error(loc(), status::ir_fp_unsupported);
            }
            if (!inst_supports_complex && is_complex_type(sty)) {
                throw compilation_error(loc(), status::ir_complex_unsupported);
            }
        };

        if (auto ct = dyn_cast<coopmatrix_data_type>(ty); ct) {
            check_scalar_ty(ct->component_ty());
        } else {
            check_scalar_ty(get_scalar_type(loc(), ty)->ty());
        }
    }
}

void arith_unary_inst::check() {
    auto ty = result().ty();

    if (isa<boolean_data_type>(*ty)) {
        if (operation_ != arithmetic_unary::not_) {
            throw compilation_error(loc(), status::ir_boolean_unsupported);
        }
    } else {
        auto const check_scalar_ty = [&](scalar_type a_ty, scalar_type r_ty) {
            // Check if inst is supported for combination of a type and result type
            switch (operation_) {
            case arithmetic_unary::abs:
            case arithmetic_unary::im:
            case arithmetic_unary::re: {
                if (r_ty != component_type(a_ty)) {
                    throw compilation_error(loc(), {&a()},
                                            status::ir_operand_type_must_match_return_type);
                }
                break;
            }
            default:
                if (a_ty != r_ty) {
                    throw compilation_error(loc(), {&a()},
                                            status::ir_operand_type_must_match_return_type);
                }
                break;
            }

            bool inst_supports_int = true;
            bool inst_supports_fp = true;
            bool inst_supports_complex = true;
            switch (operation_) {
            case arithmetic_unary::abs:
            case arithmetic_unary::neg:
                break;
            case arithmetic_unary::not_:
                inst_supports_fp = false;
                inst_supports_complex = false;
                break;
            case arithmetic_unary::conj:
            case arithmetic_unary::im:
            case arithmetic_unary::re:
                inst_supports_int = false;
                inst_supports_fp = false;
                break;
            }
            if (!inst_supports_int && is_integer_type(a_ty)) {
                throw compilation_error(loc(), {&a()}, status::ir_int_unsupported);
            }
            if (!inst_supports_fp && is_floating_type(a_ty)) {
                throw compilation_error(loc(), {&a()}, status::ir_fp_unsupported);
            }
            if (!inst_supports_complex && is_complex_type(a_ty)) {
                throw compilation_error(loc(), {&a()}, status::ir_complex_unsupported);
            }
        };

        auto ct = dyn_cast<coopmatrix_data_type>(a().ty());
        auto rt = dyn_cast<coopmatrix_data_type>(ty);
        if (ct && rt) {
            check_scalar_ty(ct->component_ty(), rt->component_ty());
        } else {
            check_scalar_ty(get_scalar_type(loc(), a())->ty(),
                            get_scalar_type(loc(), result(0))->ty());
        }
    }
}

void builtin_inst::check() {
    auto rt = dyn_cast<scalar_data_type>(result().ty());
    if (!rt) {
        throw compilation_error(loc(), status::ir_expected_scalar);
    }

    switch (builtin_type()) {
    case builtin::group_id_x:
    case builtin::group_id_y:
    case builtin::group_id_z:
    case builtin::num_groups_x:
    case builtin::num_groups_y:
    case builtin::num_groups_z:
        if (rt->ty() != scalar_type::index) {
            throw compilation_error(loc(), status::ir_expected_index);
        }
        break;
    case builtin::num_subgroups_x:
    case builtin::num_subgroups_y:
    case builtin::subgroup_size:
    case builtin::subgroup_id_x:
    case builtin::subgroup_id_y:
    case builtin::subgroup_linear_id:
    case builtin::subgroup_local_id:
        if (rt->ty() != scalar_type::i32) {
            throw compilation_error(loc(), status::ir_expected_i32);
        }
        break;
    }
}

auto builtin_inst::kind() const -> tinytc::inst_execution_kind {
    switch (builtin_type()) {
    case builtin::group_id_x:
    case builtin::group_id_y:
    case builtin::group_id_z:
    case builtin::num_groups_x:
    case builtin::num_groups_y:
    case builtin::num_groups_z:
    case builtin::num_subgroups_x:
    case builtin::num_subgroups_y:
    case builtin::subgroup_size:
        return tinytc::inst_execution_kind::mixed;
    case builtin::subgroup_id_x:
    case builtin::subgroup_id_y:
    case builtin::subgroup_linear_id:
    case builtin::subgroup_local_id:
        return tinytc::inst_execution_kind::spmd;
    }
    return tinytc::inst_execution_kind::spmd;
}

void cast_inst::check() {
    auto to_ty = result().ty();

    if (auto rt = dyn_cast<coopmatrix_data_type>(to_ty); rt) {
        auto ct = dyn_cast<coopmatrix_data_type>(a().ty());
        if (!ct) {
            throw compilation_error(loc(), {&a()}, status::ir_expected_coopmatrix);
        }
        if (ct->rows() != rt->rows() || ct->cols() != rt->cols()) {
            throw compilation_error(lc, {&a()}, status::ir_forbidden_cast);
        }
        const bool use_matches = ct->use() == rt->use();
        const bool use_conversion_allowed =
            ct->use() == matrix_use::acc &&
            (rt->use() == matrix_use::a || rt->use() == matrix_use::b);
        if (!use_matches && !use_conversion_allowed) {
            throw compilation_error(lc, {&a()}, status::ir_forbidden_cast);
        }
        if (!is_cast_allowed(ct->component_ty(), rt->component_ty())) {
            throw compilation_error(loc(), {&a()}, status::ir_forbidden_cast);
        }
    } else {
        auto to_ty_scalar = dyn_cast<scalar_data_type>(to_ty);
        if (to_ty_scalar == nullptr) {
            throw compilation_error(lc, status::ir_expected_scalar);
        }

        auto at = get_scalar_type(loc(), a());
        if (!is_cast_allowed(at->ty(), to_ty_scalar->ty())) {
            throw compilation_error(loc(), {&a()}, status::ir_forbidden_cast);
        }
    }
}

compare_inst::check() {
    auto ty = result().ty();

    if (!isa<boolean_data_type>(*ty)) {
        throw compilation_error(loc(), status::ir_expected_boolean);
    }

    auto at = get_scalar_type(loc(), a());
    auto bt = get_scalar_type(loc(), b());

    if (at->ty() != bt->ty()) {
        throw compilation_error(loc(), {&a(), &b()}, status::ir_scalar_mismatch);
    }

    bool inst_supports_complex = true;
    switch (cond_) {
    case cmp_condition::eq:
    case cmp_condition::ne:
        break;
    case cmp_condition::gt:
    case cmp_condition::ge:
    case cmp_condition::lt:
    case cmp_condition::le:
        inst_supports_complex = false;
        break;
    }
    if (!inst_supports_complex && is_complex_type(at->ty())) {
        throw compilation_error(loc(), {&a(), &b()}, status::ir_complex_unsupported);
    }
}

void constant_inst::check() {
    auto ty = result().ty();

    const auto type_ok = [](value_type const &val, scalar_type ty) {
        return (is_integer_type(ty) && std::holds_alternative<std::int64_t>(val)) ||
               (is_floating_type(ty) && std::holds_alternative<double>(val)) ||
               (is_complex_type(ty) && std::holds_alternative<std::complex<double>>(val));
    };

    if (auto bt = dyn_cast<boolean_data_type>(ty); bt) {
        if (!std::holds_alternative<bool>(value_)) {
            throw compilation_error(loc(), status::ir_constant_mismatch);
        }
    } else if (auto st = dyn_cast<scalar_data_type>(ty); st) {
        if (!type_ok(value_, st->ty())) {
            throw compilation_error(loc(), status::ir_constant_mismatch);
        }
    } else if (auto ct = dyn_cast<coopmatrix_data_type>(ty); ct) {
        if (!type_ok(value_, ct->component_ty())) {
            throw compilation_error(loc(), status::ir_constant_mismatch);
        }
    } else {
        throw compilation_error(loc(), status::ir_expected_coopmatrix_scalar_or_boolean);
    }
}

auto constant_inst::is_zero() const -> bool {
    return std::visit([](auto const &v) { return v == decltype(v){0}; }, value());
}
auto constant_inst::is_identity() const -> bool {
    return std::visit([](auto const &v) { return v == decltype(v){1}; }, value());
}

void cooperative_matrix_apply_inst::check() {
    auto ty = result().ty();

    if (a().ty() != ty) {
        throw compilation_error(loc(), {&a()}, status::ir_operand_type_must_match_return_type);
    }

    auto at = get_coopmatrix_type(loc(), a());

    auto i32_ty = scalar_data_type::get(at->context(), scalar_type::i32);

    body().loc(lc);
    body().defining_inst(this);
    body().set_num_params(3);
    body().set_param(0, i32_ty);
    body().set_param(1, i32_ty);
    body().set_param(2, at->ty());
}

void cooperative_matrix_extract_inst::check() {
    auto ty = result().ty();

    auto matt = get_coopmatrix_type(loc(), mat());
    if (matt->ty() != ty) {
        throw compilation_error(loc(), {&mat()}, status::ir_scalar_mismatch);
    }
}

void cooperative_matrix_insert_inst::check() {
    auto ty = result().ty();

    if (mat().ty() != ty) {
        throw compilation_error(loc(), {&mat()}, status::ir_operand_type_must_match_return_type);
    }

    auto valt = get_scalar_type(loc(), val());
    auto matt = get_coopmatrix_type(loc(), mat());
    if (matt->ty() != valt) {
        throw compilation_error(loc(), {&val(), &mat()}, status::ir_scalar_mismatch);
    }
}

void cooperative_matrix_load_inst::check() {
    auto rt = dyn_cast<coopmatrix_data_type>(result().ty());
    if (!rt) {
        throw compilation_error(loc(), status::ir_expected_coopmatrix);
    }

    auto ot = get_memref_type(loc(), operand());
    if (ot->element_ty() != rt->component_ty()) {
        throw compilation_error(loc(), {&operand()}, status::ir_scalar_mismatch);
    }
    if (ot->dim() != 2) {
        throw compilation_error(loc(), {&operand()}, status::ir_expected_memref_order_2);
    }

    check_index_ty(lc, pos0());
    check_index_ty(lc, pos1());
}

void cooperative_matrix_mul_add_inst::check() {
    auto rt = dyn_cast<coopmatrix_data_type>(result().ty());
    if (!rt) {
        throw compilation_error(loc(), status::ir_expected_memref);
    }
    if (rt->use() != matrix_use::acc) {
        throw compilation_error(loc(), status::ir_invalid_matrix_use);
    }

    auto at = get_coopmatrix_type(loc(), a());
    auto bt = get_coopmatrix_type(loc(), b());
    auto ct = get_coopmatrix_type(loc(), c());
    if (at->use() != matrix_use::a) {
        throw compilation_error(loc(), {&a()}, status::ir_invalid_matrix_use);
    }
    if (bt->use() != matrix_use::b) {
        throw compilation_error(loc(), {&b()}, status::ir_invalid_matrix_use);
    }
    if (ct->use() != matrix_use::acc) {
        throw compilation_error(loc(), {&c()}, status::ir_invalid_matrix_use);
    }

    auto M = rt->rows();
    auto N = rt->cols();
    auto K = at->cols();
    if (rt->rows() != M || rt->cols() != N || ct->rows() != M || ct->cols() != N ||
        at->rows() != M || bt->rows() != K || bt->cols() != N) {
        std::ostringstream oss;
        oss << "Got ";
        oss << "A=" << at->rows() << "x" << at->cols() << ", ";
        oss << "B=" << bt->rows() << "x" << bt->cols() << ", ";
        oss << "C=" << ct->rows() << "x" << ct->cols() << ", ";
        oss << "result=" << rt->rows() << "x" << rt->cols();
        throw compilation_error(loc(), {&a(), &b(), &c()}, status::ir_incompatible_shapes,
                                oss.str());
    }

    const auto AB_ty = promote(at->component_ty(), bt->component_ty());
    if (!AB_ty) {
        throw compilation_error(loc(), {&a(), &b()}, status::ir_forbidden_promotion);
    }
    if (!promotable(*AB_ty, ct->component_ty())) {
        throw compilation_error(loc(), {&a(), &b(), &c()}, status::ir_forbidden_promotion);
    }
    if (!is_cast_allowed(ct->component_ty(), rt->component_ty())) {
        throw compilation_error(loc(), {&c()}, status::ir_forbidden_cast);
    }
}

auto cooperative_matrix_mul_add_inst::is_c_zero() const -> bool {
    if (auto c_def = c().defining_inst(); c_def) {
        if (auto *c_def_const = dyn_cast<const constant_inst>(c_def); c_def_const) {
            return std::visit(
                overloaded{[](bool) { return false; }, [](auto v) { return v == decltype(v){0}; }},
                c_def_const->value());
        }
    }
    return false;
}

void cooperative_matrix_prefetch_inst::check() {
    auto ot = get_memref_type(loc(), operand());
    if (ot->dim() != 2) {
        throw compilation_error(loc(), {&operand()}, status::ir_expected_memref_order_2);
    }
    if (rows_ <= 0 || cols_ <= 0) {
        throw compilation_error(loc(), {}, status::ir_invalid_shape);
    }

    check_index_ty(lc, pos0());
    check_index_ty(lc, pos1());
}

void cooperative_matrix_reduce_inst::check() {
    auto at = get_coopmatrix_type(loc(), a());
    auto rt = get_coopmatrix_type(loc(), result().ty());
    if (at->ty() != rt->ty()) {
        throw compilation_error(loc(), {&a()}, status::ir_scalar_mismatch);
    }
    if (at->use() != rt->use()) {
        throw compilation_error(loc(), {&a()}, status::ir_invalid_matrix_use);
    }
    const int m = mode_ == reduce_mode::column ? 0 : 1;
    if (rt->shape(1 - m) != at->shape(1 - m) || rt->shape(m) != 1) {
        throw compilation_error(loc(), {&a()}, status::ir_invalid_shape);
    }
}

void cooperative_matrix_scale_inst::check() {
    auto ty = result().ty();

    if (b().ty() != ty) {
        throw compilation_error(loc(), {&b()}, status::ir_operand_type_must_match_return_type);
    }

    auto at = get_scalar_type(loc(), a());
    auto bt = get_coopmatrix_type(loc(), b());

    if (at->ty() != bt->component_ty()) {
        throw compilation_error(loc(), {&a(), &b()}, status::ir_scalar_mismatch);
    }
}

void cooperative_matrix_store_inst::check() {
    auto vt = get_coopmatrix_type(loc(), val());
    auto ot = get_memref_type(loc(), operand());
    if (vt->component_ty() != ot->element_ty()) {
        throw compilation_error(loc(), {&val(), &operand()}, status::ir_scalar_mismatch);
    }
    if (ot->dim() != 2) {
        throw compilation_error(loc(), {&operand()}, status::ir_expected_memref_order_2);
    }

    check_index_ty(loc(), pos0());
    check_index_ty(loc(), pos1());
}

void cumsum_inst::check() {
    auto a = get_memref_type(loc(), A());
    auto b = get_memref_type(loc(), B());

    if (a->dim() < 1) {
        throw compilation_error(loc(), {&A()}, status::ir_expected_non_scalar_memref);
    }
    if (mode_ >= a->dim()) {
        throw compilation_error(loc(), {&A()}, status::ir_out_of_bounds);
    }

    bool shape_equal = a->dim() == b->dim();
    if (shape_equal) {
        for (std::int64_t i = 0; i < a->dim(); ++i) {
            shape_equal = shape_equal && a->shape(i) == b->shape(i);
        }
    }

    if (!shape_equal) {
        throw compilation_error(loc(), {&A(), &B()}, status::ir_incompatible_shapes);
    }
}

void expand_inst::check() {
    for (auto &es : expand_shape()) {
        check_index_ty(loc(), *es);
    }

    auto ty = result().ty();

    auto [ot, rt] = get_and_check_memref_type_addrspace(operand(), ty, loc());

    bool const range_ok = 0 <= expanded_mode_ && expanded_mode_ < ot->dim();
    if (!range_ok) {
        throw compilation_error(loc(), {&operand()}, status::ir_out_of_bounds);
    }

    if (static_expand_shape_.size() < 2) {
        throw compilation_error(loc(), status::ir_expand_shape_order_too_small);
    }
    if (std::count(static_expand_shape_.begin(), static_expand_shape_.end(), dynamic) !=
        num_operands() - 1) {
        throw compilation_error(loc(), status::ir_expand_shape_mismatch);
    }

    for (std::int64_t i = 0; i < expanded_mode_; ++i) {
        check_memref_mode(rt, i, ot, i, loc());
    }
    auto stride = ot->stride(expanded_mode_);
    for (std::size_t i = 0; i < static_expand_shape_.size(); ++i) {
        const auto mode = expanded_mode_ + i;
        if (rt->shape(mode) != static_expand_shape()[i]) {
            auto extra_info = std::ostringstream{}
                              << "Size of mode " << mode << " does not match static expand shape ("
                              << rt->shape(mode) << "!=" << static_expand_shape()[i] << ")";
            throw compilation_error(loc(), status::ir_invalid_shape, std::move(extra_info).str());
        }
        if (!is_dynamic_value(rt->stride(mode)) && rt->stride(mode) != stride) {
            auto extra_info = std::ostringstream{} << "Stride of mode " << mode << " is invalid ("
                                                   << rt->stride(mode) << "!=" << stride << ")";
            throw compilation_error(loc(), status::ir_invalid_stride, std::move(extra_info).str());
        }
        stride = is_dynamic_value(stride) || is_dynamic_value(rt->shape(mode))
                     ? dynamic
                     : stride * rt->shape(mode);
    }
    for (std::int64_t i = expanded_mode_ + 1; i < ot->dim(); ++i) {
        check_memref_mode(rt, i + static_expand_shape_.size() - 1, ot, i, loc());
    }
}

void for_inst::setup_regions() {
    auto res = results();

    body().set_num_params(1 + res.size());
    body().set_param(0, scalar_type::get(get().context(), loop_var_type()));

    if (iter_init.size() != res.size()) {
        throw compilation_error(loc(), status::ir_init_return_type_mismatch);
    }
    auto init = iter_init();
    for (std::int64_t i = 0; i < res.size(); ++i) {
        auto ty = res[i].ty();
        if (init[i].ty() != ty) {
            throw compilation_error(loc(), {init[i]}, status::ir_init_return_type_mismatch);
        }
        if (!isa<boolean_data_type>(*ty) && !isa<scalar_data_type>(*ty) &&
            !isa<coopmatrix_data_type>(*ty)) {
            throw compilation_error(loc(), status::ir_expected_coopmatrix_scalar_or_boolean);
        }
        body().set_param(1 + i, ty);
    }
}

void for_inst::check() {
    auto lvt = get_scalar_type(loc(), loop_var());
    auto fromt = get_scalar_type(loc(), from());
    auto tot = get_scalar_type(loc(), to());

    if (!is_integer_type(lvt->ty())) {
        throw compilation_error(loc(), status::ir_expected_int);
    }
    if (lvt->ty() != fromt->ty()) {
        throw compilation_error(loc(), {&from()}, status::ir_scalar_mismatch);
    }
    if (lvt->ty() != tot->ty()) {
        throw compilation_error(loc(), {&to()}, status::ir_scalar_mismatch);
    }
    if (has_step()) {
        auto stept = get_scalar_type(loc(), step());
        if (lvt->ty() != stept->ty()) {
            throw compilation_error(loc(), {&step()}, status::ir_scalar_mismatch);
        }
    }
}

void foreach_inst::setup_regions() {
    auto lv_ty = scalar_type::get(get().context(), loop_var_type());
    auto num_lv = from.size();
    body().set_num_params(num_lv);
    for (std::int64_t i = 0; i < num_lv; ++i) {
        body().set_param(i, lv_ty);
    }
    body().kind(region_kind::spmd);
}

foreach_inst::check() {
    if (from().size() == 0 || from().size() != to().size()) {
        throw compilation_error(loc(), status::ir_from_to_mismatch);
    }

    if (!is_integer_type(loop_var_type()) ||
        std::any_of(op_begin(), op_end(),
                    [&loop_var_type](tinytc_value &val) { return val.ty() != loop_var_type; })) {
        throw compilation_error(loc(), status::ir_scalar_mismatch);
    }
}

fuse_inst::fuse_inst(tinytc_value_t op0, std::int64_t from, std::int64_t to, tinytc_data_type_t ty,
                     location const &lc)
    : standard_inst{IK::fuse}, from_(from), to_(to) {
    op(0, op0);
    loc(lc);

    auto [ot, rt] = get_and_check_memref_type_addrspace(operand(), ty, loc());

    bool const range_ok = 0 <= from_ && from_ < to_ && to_ < ot->dim();
    if (!range_ok) {
        throw compilation_error(loc(), status::ir_out_of_bounds);
    }

    for (std::int64_t i = 0; i < from_; ++i) {
        check_memref_mode(rt, i, ot, i, loc());
    }

    std::int64_t prod = 1;
    for (std::int64_t i = from_; i <= to_; ++i) {
        if (is_dynamic_value(ot->shape(i))) {
            prod = dynamic;
            break;
        }
        prod *= ot->shape(i);
    }
    if (rt->shape(from_) != prod) {
        auto extra_info = std::ostringstream{} << "Size of mode " << from_
                                               << " does not match shape product ("
                                               << rt->shape(from_) << "!=" << prod << ")";
        throw compilation_error(loc(), status::ir_invalid_shape, std::move(extra_info).str());
    }
    check_memref_stride(rt, from_, ot, from_, loc());

    for (std::int64_t i = to_ + 1; i < ot->dim(); ++i) {
        check_memref_mode(rt, i - to_ + from_, ot, i, loc());
    }
}

load_inst::load_inst(tinytc_value_t op0, array_view<tinytc_value_t> index_list0,
                     tinytc_data_type_t ty, location const &lc)
    : standard_inst{IK::load, static_cast<std::int64_t>(1 + index_list0.size())} {
    op(0, op0);
    for (std::size_t i = 0; i < index_list0.size(); ++i) {
        check_index_ty(lc, *index_list0[i]);
        op(1 + i, index_list0[i]);
    }
    loc(lc);

    visit(overloaded{
              [&](group_data_type &g) {
                  if (g.ty() != ty) {
                      throw compilation_error(loc(), {&operand()},
                                              status::ir_operand_type_must_match_return_type);
                  }
                  if (static_cast<std::int64_t>(index_list().size()) != 1) {
                      throw compilation_error(loc(), status::ir_invalid_number_of_indices);
                  }
              },
              [&](memref_data_type &m) {
                  if (m.element_data_ty() != ty) {
                      throw compilation_error(loc(), {&operand()},
                                              status::ir_operand_type_must_match_return_type);
                  }
                  if (m.dim() != static_cast<std::int64_t>(index_list().size())) {
                      throw compilation_error(loc(), status::ir_invalid_number_of_indices);
                  }
              },
              [&](auto &) { throw compilation_error(loc(), status::ir_expected_memref_or_group); }},
          *operand().ty());
}

gemm_inst::gemm_inst(transpose tA, transpose tB, tinytc_value_t alpha0, tinytc_value_t A0,
                     tinytc_value_t B0, tinytc_value_t beta0, tinytc_value_t C0, bool atomic,
                     location const &lc)
    : blas_a3_inst(IK::gemm_blas_a3, std::move(alpha0), std::move(A0), std::move(B0),
                   std::move(beta0), std::move(C0), atomic, lc),
      tA_(tA), tB_(tB) {
    auto a = get_memref_type(loc(), A());
    auto b = get_memref_type(loc(), B());
    auto c = get_memref_type(loc(), C());

    if (a->dim() != 2) {
        throw compilation_error(loc(), {&A()}, status::ir_expected_memref_order_2);
    }
    if (b->dim() != 2) {
        throw compilation_error(loc(), {&B()}, status::ir_expected_memref_order_2);
    }
    if (c->dim() != 2) {
        throw compilation_error(loc(), {&C()}, status::ir_expected_memref_order_2);
    }

    auto ak = tA_ == transpose::T ? 0 : 1;
    auto bk = tB_ == transpose::T ? 1 : 0;
    auto M = c->shape(0);
    auto N = c->shape(1);
    auto K = a->shape(ak);
    if (a->shape(1 - ak) != M || b->shape(bk) != K || b->shape(1 - bk) != N) {
        std::ostringstream oss;
        oss << "Got ";
        oss << "A=" << a->shape(0) << "x" << a->shape(1) << ", ";
        oss << "B=" << b->shape(0) << "x" << b->shape(1) << ", ";
        oss << "C=" << c->shape(0) << "x" << c->shape(1);
        throw compilation_error(loc(), {&A(), &B(), &C()}, status::ir_incompatible_shapes,
                                oss.str());
    }
}

gemv_inst::gemv_inst(transpose tA, tinytc_value_t alpha0, tinytc_value_t A0, tinytc_value_t B0,
                     tinytc_value_t beta0, tinytc_value_t C0, bool atomic, location const &lc)
    : blas_a3_inst(IK::gemv_blas_a3, std::move(alpha0), std::move(A0), std::move(B0),
                   std::move(beta0), std::move(C0), atomic, lc),
      tA_(tA) {
    auto a = get_memref_type(loc(), A());
    auto b = get_memref_type(loc(), B());
    auto c = get_memref_type(loc(), C());

    if (a->dim() != 2) {
        throw compilation_error(loc(), {&A()}, status::ir_expected_memref_order_2);
    }
    if (b->dim() != 1) {
        throw compilation_error(loc(), {&B()}, status::ir_expected_memref_order_1);
    }
    if (c->dim() != 1) {
        throw compilation_error(loc(), {&C()}, status::ir_expected_memref_order_1);
    }

    auto ak = tA_ == transpose::T ? 0 : 1;
    auto M = c->shape(0);
    auto K = a->shape(ak);
    if (a->shape(1 - ak) != M || b->shape(0) != K) {
        std::ostringstream oss;
        oss << "Got ";
        oss << "A=" << a->shape(0) << "x" << a->shape(1) << ", ";
        oss << "b=" << b->shape(0) << ", ";
        oss << "c=" << c->shape(0);
        throw compilation_error(loc(), {&A(), &B(), &C()}, status::ir_incompatible_shapes,
                                oss.str());
    }
}

ger_inst::ger_inst(tinytc_value_t alpha0, tinytc_value_t A0, tinytc_value_t B0,
                   tinytc_value_t beta0, tinytc_value_t C0, bool atomic, location const &lc)
    : blas_a3_inst(IK::ger_blas_a3, std::move(alpha0), std::move(A0), std::move(B0),
                   std::move(beta0), std::move(C0), atomic, lc) {
    auto a = get_memref_type(loc(), A());
    auto b = get_memref_type(loc(), B());
    auto c = get_memref_type(loc(), C());

    if (a->dim() != 1) {
        throw compilation_error(loc(), {&A()}, status::ir_expected_memref_order_1);
    }
    if (b->dim() != 1) {
        throw compilation_error(loc(), {&B()}, status::ir_expected_memref_order_1);
    }
    if (c->dim() != 2) {
        throw compilation_error(loc(), {&C()}, status::ir_expected_memref_order_2);
    }

    auto M = c->shape(0);
    auto N = c->shape(1);
    if (a->shape(0) != M || b->shape(0) != N) {
        std::ostringstream oss;
        oss << "Got ";
        oss << "a=" << a->shape(0) << ", ";
        oss << "b=" << b->shape(0) << ", ";
        oss << "C=" << c->shape(0) << "x" << c->shape(1);
        throw compilation_error(loc(), {&A(), &B(), &C()}, status::ir_incompatible_shapes,
                                oss.str());
    }
}

hadamard_inst::hadamard_inst(tinytc_value_t alpha0, tinytc_value_t A0, tinytc_value_t B0,
                             tinytc_value_t beta0, tinytc_value_t C0, bool atomic,
                             location const &lc)
    : blas_a3_inst(IK::hadamard_blas_a3, std::move(alpha0), std::move(A0), std::move(B0),
                   std::move(beta0), std::move(C0), atomic, lc) {
    auto a = get_memref_type(loc(), A());
    auto b = get_memref_type(loc(), B());
    auto c = get_memref_type(loc(), C());

    if (a->dim() != 1 && a->dim() != 2) {
        throw compilation_error(loc(), {&A()}, status::ir_expected_memref_order_1_or_2);
    }
    if (b->dim() != 1 && b->dim() != 2) {
        throw compilation_error(loc(), {&B()}, status::ir_expected_memref_order_1_or_2);
    }
    if (c->dim() != 1 && c->dim() != 2) {
        throw compilation_error(loc(), {&C()}, status::ir_expected_memref_order_1_or_2);
    }
    if (c->dim() != a->dim() || c->dim() != b->dim()) {
        throw compilation_error(loc(), {&A(), &B(), &C()}, status::ir_incompatible_shapes);
    }

    auto M = c->shape(0);
    if (c->dim() == 1) {
        if (a->shape(0) != M || b->shape(0) != M) {
            std::ostringstream oss;
            oss << "Got ";
            oss << "a=" << a->shape(0) << ", ";
            oss << "b=" << b->shape(0) << ", ";
            oss << "c=" << c->shape(0);
            throw compilation_error(loc(), {&A(), &B(), &C()}, status::ir_incompatible_shapes,
                                    oss.str());
        }
    } else if (c->dim() == 2) {
        auto N = c->shape(1);
        if (a->shape(0) != M || a->shape(1) != N || b->shape(0) != M || b->shape(1) != N) {
            std::ostringstream oss;
            oss << "Got ";
            oss << "A=" << a->shape(0) << "x" << a->shape(1) << ", ";
            oss << "B=" << b->shape(0) << "x" << b->shape(1) << ", ";
            oss << "C=" << c->shape(0) << "x" << c->shape(1);
            throw compilation_error(loc(), {&A(), &B(), &C()}, status::ir_incompatible_shapes,
                                    oss.str());
        }
    }
}

if_inst::if_inst(tinytc_value_t condition, array_view<tinytc_data_type_t> return_types,
                 location const &lc)
    : standard_inst{IK::if_, 1, static_cast<int64_t>(return_types.size())} {
    op(0, condition);
    loc(lc);
    then().loc(lc);
    then().defining_inst(this);
    otherwise().loc(lc);
    otherwise().defining_inst(this);
    if (!isa<boolean_data_type>(*condition->ty())) {
        throw compilation_error(loc(), {condition}, status::ir_expected_boolean);
    }
    for (std::size_t i = 0; i < return_types.size(); ++i) {
        if (!isa<boolean_data_type>(*return_types[i]) && !isa<scalar_data_type>(*return_types[i]) &&
            !isa<coopmatrix_data_type>(*return_types[i])) {
            throw compilation_error(loc(), status::ir_expected_coopmatrix_scalar_or_boolean);
        }
        result(i) = value_node{return_types[i], this, lc};
    }
}

math_unary_inst::math_unary_inst(math_unary operation, tinytc_value_t a0, tinytc_data_type_t ty,
                                 location const &lc)
    : standard_inst{IK::math_unary_}, operation_(operation) {
    op(0, a0);
    loc(lc);

    // Check if inst is supported for combination of a type and result type
    auto a_ty = get_scalar_type(loc(), a());

    const auto complex_supported = [](math_unary op) {
        switch (op) {
        case math_unary::exp:
        case math_unary::exp2:
        case math_unary::native_exp:
        case math_unary::native_exp2:
            return true;
        default:
            return false;
        }
    }(operation_);

    if (is_integer_type(a_ty->ty())) {
        throw compilation_error(loc(), {&a()}, status::ir_int_unsupported);
    } else if (is_complex_type(a_ty->ty()) && !complex_supported) {
        throw compilation_error(loc(), {&a()}, status::ir_complex_unsupported);
    }
}

parallel_inst::check() : standard_inst{IK::parallel} {
    loc(lc);

    child_region(0).kind(region_kind::spmd);
    child_region(0).loc(lc);
    child_region(0).defining_inst(this);
}

size_inst::size_inst(tinytc_value_t op0, std::int64_t mode, tinytc_data_type_t ty,
                     location const &lc)
    : standard_inst{IK::size}, mode_(mode) {
    op(0, op0);
    loc(lc);

    auto rt = dyn_cast<scalar_data_type>(ty);
    if (!rt || rt->ty() != scalar_type::index) {
        throw compilation_error(loc(), status::ir_expected_index);
    }

    const bool range_ok =
        visit(overloaded{[&](group_data_type &) -> bool { return 0 <= mode_ && mode_ < 1; },
                         [&](memref_data_type &m) -> bool { return 0 <= mode_ && mode_ < m.dim(); },
                         [&](auto &) -> bool {
                             throw compilation_error(loc(), status::ir_expected_memref_or_group);
                         }},
              *operand().ty());
    if (!range_ok) {
        throw compilation_error(loc(), status::ir_out_of_bounds);
    }
}

subgroup_broadcast_inst::subgroup_broadcast_inst(tinytc_value_t a0, tinytc_value_t idx0,
                                                 tinytc_data_type_t ty, location const &lc)
    : standard_inst{IK::subgroup_broadcast} {
    op(0, a0);
    op(1, idx0);
    loc(lc);

    if (!isa<scalar_data_type>(*ty)) {
        throw compilation_error(loc(), status::ir_expected_scalar);
    }

    if (a().ty() != ty) {
        throw compilation_error(loc(), {&a()}, status::ir_operand_type_must_match_return_type);
    }

    if (auto idxt = dyn_cast<scalar_data_type>(idx().ty());
        !idxt || idxt->ty() != scalar_type::i32) {
        throw compilation_error(loc(), {&idx()}, status::ir_expected_i32);
    }
}

subgroup_operation_inst::subgroup_operation_inst(group_arithmetic arith0, group_operation operation,
                                                 tinytc_value_t a0, tinytc_data_type_t ty,
                                                 location const &lc)
    : standard_inst{IK::subgroup_operation}, arith_{arith0}, operation_{operation} {
    op(0, a0);
    loc(lc);

    auto sty = get_scalar_type(loc(), a());
    if (arith() != group_arithmetic::add && is_complex_type(sty->ty())) {
        throw compilation_error(loc(), {&a()}, status::ir_complex_unsupported);
    }

    if (a().ty() != ty) {
        throw compilation_error(loc(), {&a()}, status::ir_operand_type_must_match_return_type);
    }
}

subview_inst::subview_inst(tinytc_value_t op0, array_view<std::int64_t> static_offsets0,
                           array_view<std::int64_t> static_sizes0,
                           array_view<tinytc_value_t> offsets0, array_view<tinytc_value_t> sizes0,
                           tinytc_data_type_t ty, location const &lc)
    : standard_inst{IK::subview, static_cast<std::int64_t>(1 + offsets0.size() + sizes0.size())},
      static_offsets_(std::move(static_offsets0)), static_sizes_(std::move(static_sizes0)) {
    op(0, op0);
    {
        std::size_t i = 1;
        for (auto const &val : offsets0) {
            check_index_ty(loc(), *val);
            op(i++, val);
        }
        num_dyn_offsets_ = i - 1;
        for (auto const &val : sizes0) {
            check_index_ty(loc(), *val);
            op(i++, val);
        }
    }
    loc(lc);

    auto [ot, rt] = get_and_check_memref_type_addrspace(operand(), ty, loc());

    if (ot->dim() != static_cast<std::int64_t>(static_offsets_.size()) ||
        ot->dim() != static_cast<std::int64_t>(static_sizes_.size())) {
        throw compilation_error(loc(), status::ir_invalid_number_of_indices);
    }
    if (std::count(static_offsets_.begin(), static_offsets_.end(), dynamic) != num_dyn_offsets_ ||
        std::count(static_sizes_.begin(), static_sizes_.end(), dynamic) !=
            num_operands() - num_dyn_offsets_ - 1) {
        throw compilation_error(loc(), status::ir_subview_mismatch);
    }

    std::int64_t ri = 0;
    for (std::int64_t i = 0; i < ot->dim(); ++i) {
        auto offset = static_offsets_[i];
        auto size = static_sizes_[i];
        if ((offset < 0 && !is_dynamic_value(offset)) || (size < 0 && !is_dynamic_value(size))) {
            throw compilation_error(loc(), status::ir_invalid_slice);
        }
        if (size > 0 || is_dynamic_value(size)) {
            if (rt->shape(ri) != size) {
                auto extra_info = std::ostringstream{} << "Size of mode " << ri
                                                       << " does not match slice size ["
                                                       << rt->shape(ri) << "!=" << size << "]";
                throw compilation_error(loc(), status::ir_invalid_shape,
                                        std::move(extra_info).str());
            }
            check_memref_stride(rt, ri, ot, i, loc());
            ++ri;
        }
    }
}

store_inst::store_inst(store_flag flag, tinytc_value_t val0, tinytc_value_t op0,
                       array_view<tinytc_value_t> index_list0, location const &lc)
    : standard_inst{IK::store, static_cast<std::int64_t>(2 + index_list0.size())}, flag_{flag} {
    op(op_val, val0);
    op(op_operand, op0);
    {
        std::size_t i = op_operand;
        for (auto const &val : index_list0) {
            check_index_ty(lc, *val);
            op(++i, val);
        }
    }
    loc(lc);

    auto v = get_scalar_type(loc(), val());
    auto o = get_memref_type(loc(), operand());

    if (v->ty() != o->element_ty()) {
        throw compilation_error(loc(), {&val(), &operand()}, status::ir_scalar_mismatch);
    }

    if (o->dim() != static_cast<std::int64_t>(index_list0.size())) {
        throw compilation_error(loc(), {&operand()}, status::ir_invalid_number_of_indices);
    }
}

sum_inst::sum_inst(transpose tA, tinytc_value_t alpha0, tinytc_value_t A0, tinytc_value_t beta0,
                   tinytc_value_t B0, bool atomic, location const &lc)
    : blas_a2_inst(IK::sum_blas_a2, std::move(alpha0), std::move(A0), std::move(beta0),
                   std::move(B0), atomic, lc),
      tA_(tA) {
    auto a = get_memref_type(loc(), A());
    auto b = get_memref_type(loc(), B());

    if (b->dim() == 1 && a->dim() != 2) {
        throw compilation_error(loc(), {&A()}, status::ir_expected_memref_order_2);
    }
    if (b->dim() == 0 && a->dim() != 1) {
        throw compilation_error(loc(), {&A()}, status::ir_expected_memref_order_1);
    }
    if (b->dim() != 0 && b->dim() != 1) {
        throw compilation_error(loc(), {&B()}, status::ir_expected_memref_order_0_or_1);
    }

    if (a->dim() == 2) {
        if (a->shape(tA_ == transpose::T ? 1 : 0) != b->shape(0)) {
            throw compilation_error(loc(), {&A(), &B()}, status::ir_incompatible_shapes);
        }
    }
}

yield_inst::check() : standard_inst{IK::yield, static_cast<std::int64_t>(vals.size())} {
    loc(lc);
    for (std::size_t i = 0; i < vals.size(); ++i) {
        op(i, vals[i]);
    }
}

} // namespace tinytc
