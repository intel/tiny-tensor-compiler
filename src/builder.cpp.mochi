// Copyright (C) 2025 Intel Corporation
// SPDX-License-Identifier: BSD-3-Clause

#include "error.hpp"
#include "location.hpp"
#include "node/inst_view.hpp"
#include "node/type.hpp"
#include "tinytc/builder.h"
#include "tinytc/tinytc.hpp"
#include "tinytc/types.h"
#include "tinytc/types.hpp"
#include "util/casting.hpp"

#include <complex>
#include <cstdint>

using namespace tinytc;

extern "C" {
// もち api_builder_cpp "tinytc/instructions.anko"

tinytc_status_t tinytc_constant_inst_create_boolean(tinytc_inst_t *instr, tinytc_bool_t value,
                                                    tinytc_type_t ty,
                                                    const tinytc_location_t *loc) {
    if (instr == nullptr) {
        return tinytc_status_invalid_arguments;
    }
    return exception_to_status_code(
        [&] { *instr = constant_inst::create(value != 0, ty, get_optional(loc)).release(); });
}

tinytc_status_t tinytc_constant_inst_create_complex(tinytc_inst_t *instr, double value_re,
                                                    double value_im, tinytc_type_t ty,
                                                    const tinytc_location_t *loc) {
    if (instr == nullptr) {
        return tinytc_status_invalid_arguments;
    }
    return exception_to_status_code([&] {
        *instr =
            constant_inst::create(std::complex<double>(value_re, value_im), ty, get_optional(loc))
                .release();
    });
}

tinytc_status_t tinytc_constant_inst_create_float(tinytc_inst_t *instr, double value,
                                                  tinytc_type_t ty, const tinytc_location_t *loc) {
    if (instr == nullptr) {
        return tinytc_status_invalid_arguments;
    }
    return exception_to_status_code(
        [&] { *instr = constant_inst::create(value, ty, get_optional(loc)).release(); });
}

tinytc_status_t tinytc_constant_inst_create_int(tinytc_inst_t *instr, int64_t value,
                                                tinytc_type_t ty, const tinytc_location_t *loc) {
    if (instr == nullptr) {
        return tinytc_status_invalid_arguments;
    }
    return exception_to_status_code(
        [&] { *instr = constant_inst::create(value, ty, get_optional(loc)).release(); });
}

tinytc_status_t tinytc_constant_inst_create_one(tinytc_inst_t *instr, tinytc_type_t ty,
                                                const tinytc_location_t *loc) {
    if (instr == nullptr) {
        return tinytc_status_invalid_arguments;
    }

    if (const auto *bt = dyn_cast<boolean_data_type>(ty); bt != nullptr) {
        return exception_to_status_code(
            [&] { *instr = constant_inst::create(true, ty, get_optional(loc)).release(); });
    }

    scalar_type sty;
    if (const auto *st = dyn_cast<scalar_data_type>(ty); st != nullptr) {
        sty = st->ty();
    } else if (const auto *ct = dyn_cast<coopmatrix_data_type>(ty); ct != nullptr) {
        sty = ct->component_ty();
    } else {
        return tinytc_status_invalid_arguments;
    }

    return exception_to_status_code([&] {
        switch (sty) {
        case scalar_type::i8:
        case scalar_type::i16:
        case scalar_type::i32:
        case scalar_type::i64:
        case scalar_type::index:
            *instr = constant_inst::create(std::int64_t{1}, ty, get_optional(loc)).release();
            break;
        case scalar_type::bf16:
        case scalar_type::f16:
        case scalar_type::f32:
        case scalar_type::f64:
            *instr = constant_inst::create(double{1}, ty, get_optional(loc)).release();
            break;
        case scalar_type::c32:
        case scalar_type::c64:
            *instr =
                constant_inst::create(std::complex<double>{1}, ty, get_optional(loc)).release();
            break;
        }
    });
}

tinytc_status_t tinytc_constant_inst_create_zero(tinytc_inst_t *instr, tinytc_type_t ty,
                                                 const tinytc_location_t *loc) {
    if (instr == nullptr) {
        return tinytc_status_invalid_arguments;
    }

    if (const auto *bt = dyn_cast<boolean_data_type>(ty); bt != nullptr) {
        return exception_to_status_code(
            [&] { *instr = constant_inst::create(false, ty, get_optional(loc)).release(); });
    }

    scalar_type sty;
    if (const auto *st = dyn_cast<scalar_data_type>(ty); st != nullptr) {
        sty = st->ty();
    } else if (const auto *ct = dyn_cast<coopmatrix_data_type>(ty); ct != nullptr) {
        sty = ct->component_ty();
    } else {
        return tinytc_status_invalid_arguments;
    }

    return exception_to_status_code([&] {
        switch (sty) {
        case scalar_type::i8:
        case scalar_type::i16:
        case scalar_type::i32:
        case scalar_type::i64:
        case scalar_type::index:
            *instr = constant_inst::create(std::int64_t{0}, ty, get_optional(loc)).release();
            break;
        case scalar_type::bf16:
        case scalar_type::f16:
        case scalar_type::f32:
        case scalar_type::f64:
            *instr = constant_inst::create(double{0}, ty, get_optional(loc)).release();
            break;
        case scalar_type::c32:
        case scalar_type::c64:
            *instr =
                constant_inst::create(std::complex<double>{0}, ty, get_optional(loc)).release();
            break;
        }
    });
}
}
